/* ==========================================================
   CODEBASE SNAPSHOT - 2025-05-03 10:06:01
   Project: WebSocket
   Files: 90 (90 text, 0 binary)
   Ignored Items: 8
   ========================================================== */

/* PROJECT STRUCTURE
   ------------------------------------------------------------
   .
   ├── .idea/
   ├── .mvn/
   │   └── wrapper/
   │       └── maven-wrapper.properties
   ├── .vscode/
   │   └── settings.json
   ├── src/
   │   ├── main/
   │   │   ├── java/
   │   │   │   └── com/
   │   │   │       └── hau/
   │   │   │           └── websocket/
   │   │   │               ├── config/
   │   │   │               ├── controller/
   │   │   │               │   ├── KhoaController.java
   │   │   │               │   ├── LopHocController.java
   │   │   │               │   ├── NganhController.java
   │   │   │               │   ├── NguoiDungController.java
   │   │   │               │   ├── NhomController.java
   │   │   │               │   ├── NhomThanhVienController.java
   │   │   │               │   ├── PhongBanController.java
   │   │   │               │   ├── TinNhanController.java
   │   │   │               │   └── TinNhanTrongNhomController.java
   │   │   │               ├── dto/
   │   │   │               │   ├── request/
   │   │   │               │   │   ├── KhoaCreate.java
   │   │   │               │   │   ├── KhoaUpdate.java
   │   │   │               │   │   ├── LopHocCreate.java
   │   │   │               │   │   ├── LopHocUpdate.java
   │   │   │               │   │   ├── NganhCreate.java
   │   │   │               │   │   ├── NganhUpdate.java
   │   │   │               │   │   ├── NguoiDungCreate.java
   │   │   │               │   │   ├── NguoiDungUpdate.java
   │   │   │               │   │   ├── NhomCreate.java
   │   │   │               │   │   ├── NhomThanhVienAddRequest.java
   │   │   │               │   │   ├── NhomThanhVienUpdateRequest.java
   │   │   │               │   │   ├── NhomUpdate.java
   │   │   │               │   │   ├── PhongBanCreate.java
   │   │   │               │   │   ├── PhongBanUpdate.java
   │   │   │               │   │   ├── TinNhanCreate.java
   │   │   │               │   │   └── TinNhanTrongNhomCreate.java
   │   │   │               │   └── response/
   │   │   │               │       ├── ApiResponse.java
   │   │   │               │       ├── ErrorsResponse.java
   │   │   │               │       ├── KhoaResponse.java
   │   │   │               │       ├── LopHocResponse.java
   │   │   │               │       ├── NganhResponse.java
   │   │   │               │       ├── NguoiDungResponse.java
   │   │   │               │       ├── NhomResponse.java
   │   │   │               │       ├── NhomThamGiaResponse.java
   │   │   │               │       ├── NhomThanhVienResponse.java
   │   │   │               │       ├── PageResponse.java
   │   │   │               │       ├── PhongBanResponse.java
   │   │   │               │       ├── TinNhanResponse.java
   │   │   │               │       └── TinNhanTrongNhomResponse.java
   │   │   │               ├── entity/
   │   │   │               │   ├── CanBoPhongBan.java
   │   │   │               │   ├── Khoa.java
   │   │   │               │   ├── LoaiNguoiDung.java
   │   │   │               │   ├── LopHoc.java
   │   │   │               │   ├── Nganh.java
   │   │   │               │   ├── NguoiDung.java
   │   │   │               │   ├── Nhom.java
   │   │   │               │   ├── NhomThanhVien.java
   │   │   │               │   ├── PhongBan.java
   │   │   │               │   ├── SinhVien.java
   │   │   │               │   ├── ThanhVienNhom.java
   │   │   │               │   ├── TinNhan.java
   │   │   │               │   ├── TinNhanLop.java
   │   │   │               │   └── TinNhanNhom.java
   │   │   │               ├── exception/
   │   │   │               │   ├── AppException.java
   │   │   │               │   └── GlobalExceptionHandler.java
   │   │   │               ├── mapper/
   │   │   │               │   ├── KhoaMapper.java
   │   │   │               │   ├── LopHocMapper.java
   │   │   │               │   ├── NganhMapper.java
   │   │   │               │   ├── NguoiDungMapper.java
   │   │   │               │   ├── NhomMapper.java
   │   │   │               │   ├── NhomThanhVienMapper.java
   │   │   │               │   ├── PhongBanMapper.java
   │   │   │               │   ├── TinNhanMapper.java
   │   │   │               │   └── TinNhanTrongNhomMapper.java
   │   │   │               ├── repository/
   │   │   │               │   ├── KhoaRepository.java
   │   │   │               │   ├── LopHocRepository.java
   │   │   │               │   ├── NganhRepository.java
   │   │   │               │   ├── NguoiDungRepository.java
   │   │   │               │   ├── NhomRepository.java
   │   │   │               │   ├── NhomThanhVienRepository.java
   │   │   │               │   ├── PhongBanRepository.java
   │   │   │               │   ├── TinNhanRepository.java
   │   │   │               │   └── TinNhanTrongNhomRepository.java
   │   │   │               ├── service/
   │   │   │               │   ├── KhoaService.java
   │   │   │               │   ├── LopHocService.java
   │   │   │               │   ├── NganhService.java
   │   │   │               │   ├── NguoiDungService.java
   │   │   │               │   ├── NhomService.java
   │   │   │               │   ├── NhomThanhVienService.java
   │   │   │               │   ├── PhongBanService.java
   │   │   │               │   ├── TinNhanService.java
   │   │   │               │   └── TinNhanTrongNhomService.java
   │   │   │               └── WebSocketApplication.java
   │   │   └── resources/
   │   │       ├── static/
   │   │       ├── templates/
   │   │       └── application.yml
   │   └── test/
   │       └── java/
   │           └── com/
   │               └── hau/
   │                   └── websocket/
   │                       └── WebSocketApplicationTests.java
   ├── target/
   │   ├── classes/
   │   ├── generated-sources/
   │   ├── generated-test-sources/
   │   └── test-classes/
   ├── .gitattributes
   ├── .gitignore
   ├── HELP.md
   ├── mvnw
   ├── mvnw.cmd
   └── pom.xml
   ------------------------------------------------------------ */

/* ===== .gitattributes ===== */
/mvnw text eol=lf
*.cmd text eol=crlf


/* ===== .gitignore ===== */
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/


/* ===== mvnw ===== */
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"


/* ===== mvnw.cmd ===== */
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"


/* ===== pom.xml ===== */
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.4.4</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.hau</groupId>
    <artifactId>WebSocket</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>WebSocket</name>
    <description>WebSocket</description>
    <url/>
    <licenses>
        <license/>
    </licenses>
    <developers>
        <developer/>
    </developers>
    <scm>
        <connection/>
        <developerConnection/>
        <tag/>
        <url/>
    </scm>
    <properties>
        <java.version>21</java.version>
        <org.mapstruct.version>1.6.3</org.mapstruct.version>
        <lombok.version>1.18.36</lombok.version>
        <maven.compiler.source>${java.version}</maven.compiler.source>
        <maven.compiler.target>${java.version}</maven.compiler.target>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok-mapstruct-binding</artifactId>
            <version>0.2.0</version>
        </dependency>
        <!--MapStruct-->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${org.mapstruct.version}</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>${org.mapstruct.version}</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-crypto</artifactId>
        </dependency>
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${org.mapstruct.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>


/* ===== .mvn\wrapper\maven-wrapper.properties ===== */
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.9/apache-maven-3.9.9-bin.zip


/* ===== src\main\java\com\hau\websocket\WebSocketApplication.java ===== */
package com.hau.websocket;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WebSocketApplication {

    public static void main(String[] args) {
        SpringApplication.run(WebSocketApplication.class, args);
    }

}


/* ===== src\main\java\com\hau\websocket\controller\KhoaController.java ===== */
package com.hau.websocket.controller;

import com.hau.websocket.dto.request.KhoaCreate;
import com.hau.websocket.dto.request.KhoaUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.KhoaResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.service.KhoaService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/khoa") // Base path cho API Khoa
@RequiredArgsConstructor
public class KhoaController {

    private final KhoaService khoaService;

    /**
     * Endpoint tạo mới một Khoa.
     *
     * @param khoaCreate DTO chứa thông tin tạo mới.
     * @return ResponseEntity chứa ApiResponse với thông tin Khoa đã tạo.
     */
    @PostMapping
    public ResponseEntity<ApiResponse<KhoaResponse>> createKhoa(@RequestBody @Valid KhoaCreate khoaCreate) {
        ApiResponse<KhoaResponse> apiResponse = khoaService.createKhoa(khoaCreate);
        // Trả về status 201 Created
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    /**
     * Endpoint cập nhật thông tin Khoa.
     *
     * @param id         ID của Khoa cần cập nhật (lấy từ path variable).
     * @param khoaUpdate DTO chứa thông tin cập nhật.
     * @return ResponseEntity chứa ApiResponse với thông tin Khoa sau khi cập nhật.
     */
    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<KhoaResponse>> updateKhoa(@PathVariable Integer id, @RequestBody @Valid KhoaUpdate khoaUpdate) {
        ApiResponse<KhoaResponse> apiResponse = khoaService.updateKhoa(id, khoaUpdate);
        // Trả về status 200 OK
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    /**
     * Endpoint lấy thông tin một Khoa theo ID.
     *
     * @param id ID của Khoa cần lấy (lấy từ path variable).
     * @return ResponseEntity chứa ApiResponse với thông tin Khoa.
     */
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<KhoaResponse>> getKhoaById(@PathVariable Integer id) {
        ApiResponse<KhoaResponse> apiResponse = khoaService.getKhoaById(id);
        // Trả về status 200 OK
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    /**
     * Endpoint xóa một Khoa theo ID.
     *
     * @param id ID của Khoa cần xóa (lấy từ path variable).
     * @return ResponseEntity chứa ApiResponse với thông báo thành công.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deleteKhoa(@PathVariable Integer id) {
        ApiResponse<String> apiResponse = khoaService.deleteKhoa(id);
        // Trả về status 200 OK
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    /**
     * Endpoint lấy danh sách tất cả các Khoa (có phân trang).
     *
     * @param pageable Thông tin phân trang (page, size, sort) tự động được tạo bởi Spring
     *                 từ các request param: ?page=0&size=10&sort=tenKhoa,asc
     *                 PageableDefault đặt giá trị mặc định nếu không có param nào được truyền.
     * @return ResponseEntity chứa PageResponse với danh sách Khoa và thông tin phân trang.
     */
    @GetMapping
    public ResponseEntity<PageResponse<KhoaResponse>> getAllKhoa(@PageableDefault(size = 10, sort = "id") Pageable pageable) { // Mặc định 10 phần tử/trang, sắp xếp theo id
        PageResponse<KhoaResponse> pageResponse = khoaService.getAllKhoa(pageable);
        // Trả về status 200 OK
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }
}


/* ===== src\main\java\com\hau\websocket\controller\LopHocController.java ===== */
package com.hau.websocket.controller;

import com.hau.websocket.dto.request.LopHocCreate;
import com.hau.websocket.dto.request.LopHocUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.LopHocResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.service.LopHocService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/lop-hoc") // Base path for LopHoc API
@RequiredArgsConstructor
public class LopHocController {

    private final LopHocService lopHocService;

    @PostMapping
    public ResponseEntity<ApiResponse<LopHocResponse>> createLopHoc(@RequestBody @Valid LopHocCreate lopHocCreate) {
        ApiResponse<LopHocResponse> apiResponse = lopHocService.createLopHoc(lopHocCreate);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<LopHocResponse>> updateLopHoc(@PathVariable Integer id, @RequestBody @Valid LopHocUpdate lopHocUpdate) {
        ApiResponse<LopHocResponse> apiResponse = lopHocService.updateLopHoc(id, lopHocUpdate);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<LopHocResponse>> getLopHocById(@PathVariable Integer id) {
        ApiResponse<LopHocResponse> apiResponse = lopHocService.getLopHocById(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deleteLopHoc(@PathVariable Integer id) {
        ApiResponse<String> apiResponse = lopHocService.deleteLopHoc(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping
    public ResponseEntity<PageResponse<LopHocResponse>> getAllLopHoc(@PageableDefault(size = 10, sort = "id") Pageable pageable) { // Default 10 items/page, sort by id
        PageResponse<LopHocResponse> pageResponse = lopHocService.getAllLopHoc(pageable);
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }
}


/* ===== src\main\java\com\hau\websocket\controller\NganhController.java ===== */
package com.hau.websocket.controller;

import com.hau.websocket.dto.request.NganhCreate;
import com.hau.websocket.dto.request.NganhUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.NganhResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.service.NganhService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/nganh") // Base path for Nganh API
@RequiredArgsConstructor
public class NganhController {

    private final NganhService nganhService;

    @PostMapping
    public ResponseEntity<ApiResponse<NganhResponse>> createNganh(@RequestBody @Valid NganhCreate nganhCreate) {
        ApiResponse<NganhResponse> apiResponse = nganhService.createNganh(nganhCreate);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<NganhResponse>> updateNganh(@PathVariable Integer id, @RequestBody @Valid NganhUpdate nganhUpdate) {
        ApiResponse<NganhResponse> apiResponse = nganhService.updateNganh(id, nganhUpdate);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<NganhResponse>> getNganhById(@PathVariable Integer id) {
        ApiResponse<NganhResponse> apiResponse = nganhService.getNganhById(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deleteNganh(@PathVariable Integer id) {
        ApiResponse<String> apiResponse = nganhService.deleteNganh(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping
    public ResponseEntity<PageResponse<NganhResponse>> getAllNganh(@PageableDefault(size = 10, sort = "id") Pageable pageable) { // Default 10 items/page, sort by id
        PageResponse<NganhResponse> pageResponse = nganhService.getAllNganh(pageable);
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }
}


/* ===== src\main\java\com\hau\websocket\controller\NguoiDungController.java ===== */
package com.hau.websocket.controller;

import com.hau.websocket.dto.request.NguoiDungCreate;
import com.hau.websocket.dto.request.NguoiDungUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.NguoiDungResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.service.NguoiDungService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/nguoi-dung") // Base path for NguoiDung API
@RequiredArgsConstructor
public class NguoiDungController {

    private final NguoiDungService nguoiDungService;

    @PostMapping
    public ResponseEntity<ApiResponse<NguoiDungResponse>> createNguoiDung(@RequestBody @Valid NguoiDungCreate createDto) {
        ApiResponse<NguoiDungResponse> apiResponse = nguoiDungService.createNguoiDung(createDto);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<NguoiDungResponse>> updateNguoiDung(@PathVariable Integer id, @RequestBody @Valid NguoiDungUpdate updateDto) {
        ApiResponse<NguoiDungResponse> apiResponse = nguoiDungService.updateNguoiDung(id, updateDto);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<NguoiDungResponse>> getNguoiDungById(@PathVariable Integer id) {
        ApiResponse<NguoiDungResponse> apiResponse = nguoiDungService.getNguoiDungById(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deleteNguoiDung(@PathVariable Integer id) {
        ApiResponse<String> apiResponse = nguoiDungService.deleteNguoiDung(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping
    public ResponseEntity<PageResponse<NguoiDungResponse>> getAllNguoiDung(@PageableDefault(size = 10, sort = "id") Pageable pageable) { // Default 10 items/page, sort by id
        PageResponse<NguoiDungResponse> pageResponse = nguoiDungService.getAllNguoiDung(pageable);
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }
}


/* ===== src\main\java\com\hau\websocket\controller\NhomController.java ===== */
package com.hau.websocket.controller;

import com.hau.websocket.dto.request.NhomCreate;
import com.hau.websocket.dto.request.NhomUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.NhomResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.service.NhomService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
// Import SecurityContextHolder or Principal if needed for authorization
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/nhom") // Base path for Nhom API
@RequiredArgsConstructor
public class NhomController {

    private final NhomService nhomService;

    @PostMapping
    public ResponseEntity<ApiResponse<NhomResponse>> createNhom(@RequestBody @Valid NhomCreate createDto) {
        // Lấy ID người dùng hiện tại từ Security Context để gán nguoiTaoId
        // Integer currentUserId = getCurrentUserId(); // Implement this helper
        // createDto.setNguoiTaoId(currentUserId); // Ghi đè hoặc đảm bảo DTO đúng
        ApiResponse<NhomResponse> apiResponse = nhomService.createNhom(createDto);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<NhomResponse>> updateNhom(@PathVariable Integer id, @RequestBody @Valid NhomUpdate updateDto) {
        // Lấy ID người dùng hiện tại từ Security Context để kiểm tra quyền
        Integer currentUserId = 1; // Placeholder - Replace with actual current user ID logic
        ApiResponse<NhomResponse> apiResponse = nhomService.updateNhom(id, updateDto, currentUserId);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<NhomResponse>> getNhomById(@PathVariable Integer id) {
        // Có thể cần kiểm tra quyền xem nhóm
        ApiResponse<NhomResponse> apiResponse = nhomService.getNhomById(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deleteNhom(@PathVariable Integer id) {
        // Lấy ID người dùng hiện tại từ Security Context để kiểm tra quyền
        Integer currentUserId = 1; // Placeholder - Replace with actual current user ID logic
        ApiResponse<String> apiResponse = nhomService.deleteNhom(id, currentUserId);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping
    public ResponseEntity<PageResponse<NhomResponse>> getAllNhom(@PageableDefault(size = 10, sort = "id") Pageable pageable) {
        // Có thể cần lọc theo nhóm mà người dùng là thành viên
        PageResponse<NhomResponse> pageResponse = nhomService.getAllNhom(pageable);
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }

    // Helper method placeholder to get current user ID (implement using Spring Security)
    // private Integer getCurrentUserId() {
    //     // Logic to get user ID from SecurityContextHolder.getContext().getAuthentication()
    //     return 1; // Replace with actual implementation
    // }
}


/* ===== src\main\java\com\hau\websocket\controller\NhomThanhVienController.java ===== */
package com.hau.websocket.controller;

import com.hau.websocket.dto.request.NhomThanhVienAddRequest;
import com.hau.websocket.dto.request.NhomThanhVienUpdateRequest;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.NhomThamGiaResponse;
import com.hau.websocket.dto.response.NhomThanhVienResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.service.NhomThanhVienService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1") // Base path chung, dùng path cụ thể cho từng resource
@RequiredArgsConstructor
public class NhomThanhVienController {

    private final NhomThanhVienService nhomThanhVienService;

    /**
     * Thêm một thành viên mới vào nhóm.
     * Yêu cầu quyền admin của nhóm.
     */
    @PostMapping("/nhom/{nhomId}/thanh-vien")
    public ResponseEntity<ApiResponse<NhomThanhVienResponse>> addThanhVien(@PathVariable Integer nhomId, @RequestBody @Valid NhomThanhVienAddRequest addRequest) {
        Integer currentUserId = getCurrentUserId(); // Lấy ID người dùng hiện tại
        ApiResponse<NhomThanhVienResponse> apiResponse = nhomThanhVienService.addThanhVien(nhomId, addRequest, currentUserId);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    /**
     * Cập nhật vai trò của một thành viên trong nhóm.
     * Yêu cầu quyền admin của nhóm.
     */
    @PutMapping("/nhom/{nhomId}/thanh-vien/{nguoiDungId}")
    public ResponseEntity<ApiResponse<NhomThanhVienResponse>> updateVaiTro(@PathVariable Integer nhomId, @PathVariable Integer nguoiDungId, @RequestBody @Valid NhomThanhVienUpdateRequest updateRequest) {
        Integer currentUserId = getCurrentUserId(); // Lấy ID người dùng hiện tại
        ApiResponse<NhomThanhVienResponse> apiResponse = nhomThanhVienService.updateVaiTro(nhomId, nguoiDungId, updateRequest, currentUserId);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    /**
     * Xóa một thành viên khỏi nhóm.
     * Yêu cầu quyền admin nhóm hoặc chính thành viên đó tự rời.
     */
    @DeleteMapping("/nhom/{nhomId}/thanh-vien/{nguoiDungId}")
    public ResponseEntity<ApiResponse<String>> removeThanhVien(@PathVariable Integer nhomId, @PathVariable Integer nguoiDungId) {
        Integer currentUserId = getCurrentUserId(); // Lấy ID người dùng hiện tại
        ApiResponse<String> apiResponse = nhomThanhVienService.removeThanhVien(nhomId, nguoiDungId, currentUserId);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    /**
     * Lấy danh sách thành viên của một nhóm (phân trang).
     * Yêu cầu là thành viên của nhóm để xem.
     */
    @GetMapping("/nhom/{nhomId}/thanh-vien")
    public ResponseEntity<PageResponse<NhomThanhVienResponse>> getThanhVienByNhom(@PathVariable Integer nhomId, @PageableDefault(size = 20, sort = "ngayThamGia") Pageable pageable) {
        Integer currentUserId = getCurrentUserId(); // Lấy ID người dùng hiện tại
        // Service cần kiểm tra quyền xem
        PageResponse<NhomThanhVienResponse> pageResponse = nhomThanhVienService.getThanhVienByNhom(nhomId, pageable, currentUserId);
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }

    /**
     * Lấy danh sách các nhóm mà một người dùng tham gia (phân trang).
     */
    @GetMapping("/nguoi-dung/{nguoiDungId}/nhom")
    public ResponseEntity<PageResponse<NhomThamGiaResponse>> getNhomByNguoiDung(@PathVariable Integer nguoiDungId, @PageableDefault(size = 10, sort = "nhom.tenNhom") Pageable pageable) {
        // Có thể chỉ cho phép người dùng xem danh sách nhóm của chính họ
        // Integer currentUserId = getCurrentUserId();
        // if (!currentUserId.equals(nguoiDungId)) { /* throw exception or return empty */ }

        PageResponse<NhomThamGiaResponse> pageResponse = nhomThanhVienService.getNhomByNguoiDung(nguoiDungId, pageable);
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }


    // --- Helper Method Placeholder ---
    private Integer getCurrentUserId() {
        // TODO: Implement logic to get current user ID from Spring Security Context
        // Ví dụ:
        // Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        // if (authentication != null && authentication.getPrincipal() instanceof UserDetails) {
        //     UserDetails userDetails = (UserDetails) authentication.getPrincipal();
        //     // Giả sử UserDetails của bạn có phương thức getId() hoặc bạn có thể query DB bằng username
        //     // return ((CustomUserDetails) userDetails).getId();
        // }
        return 1; // Placeholder
    }
}


/* ===== src\main\java\com\hau\websocket\controller\PhongBanController.java ===== */
package com.hau.websocket.controller;

import com.hau.websocket.dto.request.PhongBanCreate;
import com.hau.websocket.dto.request.PhongBanUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.PhongBanResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.service.PhongBanService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/phong-ban") // Base path for PhongBan API
@RequiredArgsConstructor
public class PhongBanController {

    private final PhongBanService phongBanService;

    @PostMapping
    public ResponseEntity<ApiResponse<PhongBanResponse>> createPhongBan(@RequestBody @Valid PhongBanCreate createDto) {
        ApiResponse<PhongBanResponse> apiResponse = phongBanService.createPhongBan(createDto);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    @PutMapping("/{id}")
    public ResponseEntity<ApiResponse<PhongBanResponse>> updatePhongBan(@PathVariable Integer id, @RequestBody @Valid PhongBanUpdate updateDto) {
        ApiResponse<PhongBanResponse> apiResponse = phongBanService.updatePhongBan(id, updateDto);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<PhongBanResponse>> getPhongBanById(@PathVariable Integer id) {
        ApiResponse<PhongBanResponse> apiResponse = phongBanService.getPhongBanById(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deletePhongBan(@PathVariable Integer id) {
        ApiResponse<String> apiResponse = phongBanService.deletePhongBan(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    @GetMapping
    public ResponseEntity<PageResponse<PhongBanResponse>> getAllPhongBan(@PageableDefault(size = 10, sort = "id") Pageable pageable) { // Default 10 items/page, sort by id
        PageResponse<PhongBanResponse> pageResponse = phongBanService.getAllPhongBan(pageable);
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }
}


/* ===== src\main\java\com\hau\websocket\controller\TinNhanController.java ===== */
package com.hau.websocket.controller;

import com.hau.websocket.dto.request.TinNhanCreate;
// TinNhanUpdate không được sử dụng
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.TinNhanResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.service.TinNhanService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/tin-nhan") // Base path for TinNhan API
@RequiredArgsConstructor
public class TinNhanController {

    private final TinNhanService tinNhanService;

    /**
     * Endpoint để gửi một tin nhắn mới (1-1).
     */
    @PostMapping
    public ResponseEntity<ApiResponse<TinNhanResponse>> createTinNhan(@RequestBody @Valid TinNhanCreate createDto) {
        ApiResponse<TinNhanResponse> apiResponse = tinNhanService.createTinNhan(createDto);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    /**
     * Endpoint lấy thông tin một tin nhắn cụ thể bằng ID (ít dùng).
     */
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<TinNhanResponse>> getTinNhanById(@PathVariable Integer id) {
        ApiResponse<TinNhanResponse> apiResponse = tinNhanService.getTinNhanById(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    /**
     * Endpoint xóa một tin nhắn cụ thể bằng ID.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deleteTinNhan(@PathVariable Integer id) {
        // Cần có cơ chế xác thực quyền xóa
        ApiResponse<String> apiResponse = tinNhanService.deleteTinNhan(id);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    /**
     * Endpoint lấy danh sách tin nhắn của một cuộc trò chuyện (phân trang).
     * Sắp xếp mặc định theo thời gian giảm dần (mới nhất trước).
     */
    @GetMapping("/cuoc-tro-chuyen/{cuocTroChuyenId}")
    public ResponseEntity<PageResponse<TinNhanResponse>> getTinNhanByCuocTroChuyenId(@PathVariable String cuocTroChuyenId, @PageableDefault(size = 20, sort = "thoiGianGui") Pageable pageable) { // Mặc định 20 tin nhắn/trang
        // Lưu ý: sort = "thoiGianGui" sẽ sắp xếp tăng dần (cũ trước)
        // Repository đã mặc định DESC (mới trước) nên không cần sort ở đây, hoặc sort DESC tường minh
        // @PageableDefault(size = 20, sort = "thoiGianGui", direction = Sort.Direction.DESC)
        PageResponse<TinNhanResponse> pageResponse = tinNhanService.getTinNhanByCuocTroChuyenId(cuocTroChuyenId, pageable);
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }
}


/* ===== src\main\java\com\hau\websocket\controller\TinNhanTrongNhomController.java ===== */
package com.hau.websocket.controller;

import com.hau.websocket.dto.request.TinNhanTrongNhomCreate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.TinNhanTrongNhomResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.service.TinNhanTrongNhomService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/tin-nhan-trong-nhom") // Base path
@RequiredArgsConstructor
public class TinNhanTrongNhomController {

    private final TinNhanTrongNhomService tinNhanTrongNhomService;

    /**
     * Gửi tin nhắn mới vào nhóm (tùy chỉnh hoặc lớp học).
     */
    @PostMapping
    public ResponseEntity<ApiResponse<TinNhanTrongNhomResponse>> createTinNhanTrongNhom(@RequestBody @Valid TinNhanTrongNhomCreate createDto) {
        Integer currentUserId = getCurrentUserId(); // Lấy ID người dùng hiện tại
        // Đảm bảo người gửi là người dùng hiện tại
        createDto.setNguoiGuiId(currentUserId);
        ApiResponse<TinNhanTrongNhomResponse> apiResponse = tinNhanTrongNhomService.createTinNhanTrongNhom(createDto, currentUserId);
        return new ResponseEntity<>(apiResponse, HttpStatus.CREATED);
    }

    /**
     * Lấy thông tin chi tiết một tin nhắn trong nhóm bằng ID.
     */
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<TinNhanTrongNhomResponse>> getTinNhanTrongNhomById(@PathVariable Integer id) {
        Integer currentUserId = getCurrentUserId(); // Lấy ID người dùng hiện tại
        ApiResponse<TinNhanTrongNhomResponse> apiResponse = tinNhanTrongNhomService.getTinNhanTrongNhomById(id, currentUserId);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    /**
     * Xóa một tin nhắn trong nhóm bằng ID.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<ApiResponse<String>> deleteTinNhanTrongNhom(@PathVariable Integer id) {
        Integer currentUserId = getCurrentUserId(); // Lấy ID người dùng hiện tại
        ApiResponse<String> apiResponse = tinNhanTrongNhomService.deleteTinNhanTrongNhom(id, currentUserId);
        return new ResponseEntity<>(apiResponse, HttpStatus.OK);
    }

    /**
     * Lấy danh sách tin nhắn của một nhóm tùy chỉnh (phân trang).
     */
    @GetMapping("/nhom/{nhomId}")
    public ResponseEntity<PageResponse<TinNhanTrongNhomResponse>> getTinNhanByNhomId(@PathVariable Integer nhomId, @PageableDefault(size = 20) Pageable pageable) {
        Integer currentUserId = getCurrentUserId(); // Lấy ID người dùng hiện tại
        PageResponse<TinNhanTrongNhomResponse> pageResponse = tinNhanTrongNhomService.getTinNhanByNhomId(nhomId, pageable, currentUserId);
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }

    /**
     * Lấy danh sách tin nhắn của một lớp học (phân trang).
     */
    @GetMapping("/lop-hoc/{lopHocId}")
    public ResponseEntity<PageResponse<TinNhanTrongNhomResponse>> getTinNhanByLopHocId(@PathVariable Integer lopHocId, @PageableDefault(size = 20) Pageable pageable) {
        Integer currentUserId = getCurrentUserId(); // Lấy ID người dùng hiện tại
        PageResponse<TinNhanTrongNhomResponse> pageResponse = tinNhanTrongNhomService.getTinNhanByLopHocId(lopHocId, pageable, currentUserId);
        return new ResponseEntity<>(pageResponse, HttpStatus.OK);
    }


    // --- Helper Method Placeholder ---
    private Integer getCurrentUserId() {
        // TODO: Implement logic to get current user ID from Spring Security Context
        return 1; // Placeholder
    }
}


/* ===== src\main\java\com\hau\websocket\dto\request\KhoaCreate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

// --- DTO cho việc tạo mới Khoa ---
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class KhoaCreate {

    @NotBlank(message = "Mã khoa không được để trống")
    @Size(max = 50, message = "Mã khoa không được vượt quá 50 ký tự")
    private String maKhoa;

    @NotBlank(message = "Tên khoa không được để trống")
    @Size(max = 255, message = "Tên khoa không được vượt quá 255 ký tự")
    private String tenKhoa;
}

// --- DTO cho việc cập nhật Khoa ---
// package com.hau.websocket.dto.request; // Cùng package




/* ===== src\main\java\com\hau\websocket\dto\request\KhoaUpdate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class KhoaUpdate {
    @NotBlank(message = "Tên khoa không được để trống")
    @Size(max = 255, message = "Tên khoa không được vượt quá 255 ký tự")
    private String tenKhoa;
}

/* ===== src\main\java\com\hau\websocket\dto\request\LopHocCreate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LopHocCreate {

    @NotBlank(message = "Mã lớp không được để trống")
    @Size(max = 50, message = "Mã lớp không được vượt quá 50 ký tự")
    private String maLop;

    @NotBlank(message = "Tên lớp không được để trống")
    @Size(max = 255, message = "Tên lớp không được vượt quá 255 ký tự")
    private String tenLop;

    @Size(max = 50, message = "Niên khóa không được vượt quá 50 ký tự")
    private String nienKhoa;

    @NotNull(message = "ID Ngành không được để trống")
    private Integer nganhId; // ID của Ngành mà Lớp học này thuộc về
}


/* ===== src\main\java\com\hau\websocket\dto\request\LopHocUpdate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LopHocUpdate {

    @NotBlank(message = "Tên lớp không được để trống")
    @Size(max = 255, message = "Tên lớp không được vượt quá 255 ký tự")
    private String tenLop;

    @Size(max = 50, message = "Niên khóa không được vượt quá 50 ký tự")
    private String nienKhoa;

    @NotNull(message = "ID Ngành không được để trống")
    private Integer nganhId; // Cho phép cập nhật Ngành
}



/* ===== src\main\java\com\hau\websocket\dto\request\NganhCreate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

// --- DTO Tạo mới Ngành ---
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NganhCreate {

    @NotBlank(message = "Mã ngành không được để trống")
    @Size(max = 50, message = "Mã ngành không được vượt quá 50 ký tự")
    private String maNganh;

    @NotBlank(message = "Tên ngành không được để trống")
    @Size(max = 255, message = "Tên ngành không được vượt quá 255 ký tự")
    private String tenNganh;

    @NotNull(message = "ID Khoa không được để trống")
    private Integer khoaId; // ID của Khoa mà Ngành này thuộc về
}



/* ===== src\main\java\com\hau\websocket\dto\request\NganhUpdate.java ===== */
package com.hau.websocket.dto.request;// --- DTO Cập nhật Ngành ---
// package com.hau.websocket.dto.request; // Cùng package

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NganhUpdate {

    @NotBlank(message = "Tên ngành không được để trống")
    @Size(max = 255, message = "Tên ngành không được vượt quá 255 ký tự")
    private String tenNganh;

    @NotNull(message = "ID Khoa không được để trống")
    private Integer khoaId; // Cho phép cập nhật Khoa
}


/* ===== src\main\java\com\hau\websocket\dto\request\NguoiDungCreate.java ===== */
package com.hau.websocket.dto.request;

import com.hau.websocket.entity.LoaiNguoiDung; // Import Enum
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NguoiDungCreate {

    @NotBlank(message = "Mã đăng nhập không được để trống")
    @Size(max = 100, message = "Mã đăng nhập không quá 100 ký tự")
    private String maDangNhap;

    @NotBlank(message = "Mật khẩu không được để trống")
    // Thêm validation độ dài, độ phức tạp nếu cần ở tầng service hoặc validator riêng
    private String matKhau;

    @NotBlank(message = "Họ tên không được để trống")
    @Size(max = 255)
    private String hoTen;

    @Email(message = "Email không đúng định dạng")
    @Size(max = 255)
    private String email; // Email có thể null ban đầu, nhưng nếu có phải unique

    @Size(max = 20)
    private String soDienThoai;

    @Size(max = 500)
    private String diaChi;

    @Size(max = 500)
    private String anhDaiDien; // URL

    @NotNull(message = "Loại tài khoản không được để trống")
    private LoaiNguoiDung loaiTaiKhoan;

    // Các trường đặc thù theo loại tài khoản (có thể null)
    @Size(max = 50)
    private String maSinhVien;
    private Integer lopHocId;

    @Size(max = 50)
    private String maCanBo;
    private Integer phongBanId;

    @Size(max = 100)
    private String vaiTroNhanVien;
    private Boolean laDauMoiLienLac; // Mặc định false nếu null
}


/* ===== src\main\java\com\hau\websocket\dto\request\NguoiDungUpdate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NguoiDungUpdate {

    // Không cho phép cập nhật maDangNhap, loaiTaiKhoan, maSinhVien, maCanBo qua DTO này
    // Mật khẩu nên có endpoint riêng

    @NotBlank(message = "Họ tên không được để trống")
    @Size(max = 255)
    private String hoTen;

    @Email(message = "Email không đúng định dạng")
    @Size(max = 255)
    private String email; // Cần kiểm tra unique nếu thay đổi

    @Size(max = 20)
    private String soDienThoai;

    @Size(max = 500)
    private String diaChi;

    @Size(max = 500)
    private String anhDaiDien;

    @NotNull(message = "Trạng thái không được để trống")
    private Boolean trangThai; // Cho phép cập nhật trạng thái active/inactive

    // Cho phép cập nhật lớp học, phòng ban, vai trò
    private Integer lopHocId;
    private Integer phongBanId;

    @Size(max = 100)
    private String vaiTroNhanVien;
    private Boolean laDauMoiLienLac;
}



/* ===== src\main\java\com\hau\websocket\dto\request\NhomCreate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NhomCreate {

    @NotBlank(message = "Tên nhóm không được để trống")
    @Size(max = 255)
    private String tenNhom;

    private String moTa;

    @Size(max = 500)
    private String anhDaiDienNhom; // URL

    @NotNull(message = "ID người tạo không được để trống")
    private Integer nguoiTaoId; // ID của người dùng tạo nhóm

    @Size(max = 50)
    private String loaiNhom; // Mặc định là "TuyChinh" nếu null
}


/* ===== src\main\java\com\hau\websocket\dto\request\NhomThanhVienAddRequest.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NhomThanhVienAddRequest {

    // nhomId thường sẽ lấy từ PathVariable của endpoint

    @NotNull(message = "ID người dùng không được để trống")
    private Integer nguoiDungId; // ID của người dùng được thêm vào

    @Size(max = 50, message = "Vai trò không được vượt quá 50 ký tự")
    private String vaiTroTrongNhom; // Optional, mặc định là "ThanhVien" nếu null
}


/* ===== src\main\java\com\hau\websocket\dto\request\NhomThanhVienUpdateRequest.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NhomThanhVienUpdateRequest {

    @NotBlank(message = "Vai trò không được để trống")
    @Size(max = 50, message = "Vai trò không được vượt quá 50 ký tự")
    private String vaiTroTrongNhom; // Vai trò mới cần cập nhật
}



/* ===== src\main\java\com\hau\websocket\dto\request\NhomUpdate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NhomUpdate {

    // Không cho phép cập nhật người tạo nhóm

    @NotBlank(message = "Tên nhóm không được để trống")
    @Size(max = 255)
    private String tenNhom;

    private String moTa;

    @Size(max = 500)
    private String anhDaiDienNhom;

    @Size(max = 50)
    private String loaiNhom;
}



/* ===== src\main\java\com\hau\websocket\dto\request\PhongBanCreate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PhongBanCreate {

    @NotBlank(message = "Mã phòng ban không được để trống")
    @Size(max = 50, message = "Mã phòng ban không được vượt quá 50 ký tự")
    private String maPhongBan;

    @NotBlank(message = "Tên phòng ban không được để trống")
    @Size(max = 255, message = "Tên phòng ban không được vượt quá 255 ký tự")
    private String tenPhongBan;

    private String moTa; // Không bắt buộc

    @Email(message = "Email liên hệ không đúng định dạng")
    @Size(max = 255)
    private String emailLienHe; // Không bắt buộc

    @Size(max = 20, message = "Số điện thoại liên hệ không được vượt quá 20 ký tự")
    private String soDienThoaiLienHe; // Không bắt buộc
}


/* ===== src\main\java\com\hau\websocket\dto\request\PhongBanUpdate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PhongBanUpdate {

    // Không cho phép cập nhật mã phòng ban

    @NotBlank(message = "Tên phòng ban không được để trống")
    @Size(max = 255, message = "Tên phòng ban không được vượt quá 255 ký tự")
    private String tenPhongBan;

    private String moTa;

    @Email(message = "Email liên hệ không đúng định dạng")
    @Size(max = 255)
    private String emailLienHe;

    @Size(max = 20, message = "Số điện thoại liên hệ không được vượt quá 20 ký tự")
    private String soDienThoaiLienHe;
}



/* ===== src\main\java\com\hau\websocket\dto\request\TinNhanCreate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TinNhanCreate {

    @NotBlank(message = "ID cuộc trò chuyện không được để trống")
    @Size(max = 100)
    private String cuocTroChuyenId;

    @NotNull(message = "ID người gửi không được để trống")
    private Integer nguoiGuiId;

    @NotNull(message = "ID người nhận không được để trống")
    private Integer nguoiNhanId;

    // Nội dung hoặc tệp đính kèm phải có ít nhất một
    // Validation này phức tạp hơn, thường xử lý ở Service hoặc custom validator
    private String noiDung;

    @Size(max = 500)
    private String dinhKemUrl;

    @Size(max = 255)
    private String dinhKemTenGoc;

    @Size(max = 100)
    private String dinhKemLoai;
}


/* ===== src\main\java\com\hau\websocket\dto\request\TinNhanTrongNhomCreate.java ===== */
package com.hau.websocket.dto.request;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TinNhanTrongNhomCreate {

    // Chỉ một trong hai trường này được phép có giá trị
    private Integer nhomId;
    private Integer lopHocId;

    @NotNull(message = "ID người gửi không được để trống")
    private Integer nguoiGuiId;

    // Phải có nội dung hoặc tệp đính kèm (validate ở Service)
    private String noiDung;

    @Size(max = 500)
    private String dinhKemUrl;

    @Size(max = 255)
    private String dinhKemTenGoc;

    @Size(max = 100)
    private String dinhKemLoai;
}


/* ===== src\main\java\com\hau\websocket\dto\response\ApiResponse.java ===== */
package com.hau.websocket.dto.response;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@JsonIgnoreProperties(ignoreUnknown = true)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private int status;
    private String message;
    private T result;
    private LocalDateTime timestamp;
}


/* ===== src\main\java\com\hau\websocket\dto\response\ErrorsResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorsResponse {
    private int status;
    private String message;
    private Object error;
    private LocalDateTime timestamp;
}


/* ===== src\main\java\com\hau\websocket\dto\response\KhoaResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class KhoaResponse {
    private Integer id;
    private String maKhoa;
    private String tenKhoa;
    private LocalDateTime ngayTao;
    private LocalDateTime ngayCapNhat;
}


/* ===== src\main\java\com\hau\websocket\dto\response\LopHocResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LopHocResponse {
    private Integer id;
    private String maLop;
    private String tenLop;
    private String nienKhoa;
    private Integer nganhId;    // ID của Ngành liên quan
    private String tenNganh;    // Tên của Ngành liên quan
    private LocalDateTime ngayTao;
    private LocalDateTime ngayCapNhat;
}


/* ===== src\main\java\com\hau\websocket\dto\response\NganhResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NganhResponse {
    private Integer id;
    private String maNganh;
    private String tenNganh;
    private Integer khoaId;     // ID của Khoa liên quan
    private String tenKhoa;     // Tên của Khoa liên quan (lấy từ object Khoa)
    private LocalDateTime ngayTao;
    private LocalDateTime ngayCapNhat;
}


/* ===== src\main\java\com\hau\websocket\dto\response\NguoiDungResponse.java ===== */
package com.hau.websocket.dto.response;

import com.hau.websocket.entity.LoaiNguoiDung;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NguoiDungResponse {
    private Integer id;
    private String maDangNhap;
    // Không bao gồm matKhau
    private String hoTen;
    private String email;
    private String soDienThoai;
    private String diaChi;
    private String anhDaiDien;
    private LoaiNguoiDung loaiTaiKhoan;
    private Boolean trangThai;
    private String maSinhVien;
    private Integer lopHocId;
    private String tenLopHoc; // Thêm tên lớp học
    private String maCanBo;
    private Integer phongBanId;
    private String tenPhongBan; // Thêm tên phòng ban
    private String vaiTroNhanVien;
    private Boolean laDauMoiLienLac;
    private LocalDateTime ngayTao;
    private LocalDateTime ngayCapNhat;
}


/* ===== src\main\java\com\hau\websocket\dto\response\NhomResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NhomResponse {
    private Integer id;
    private String tenNhom;
    private String moTa;
    private String anhDaiDienNhom;
    private Integer nguoiTaoId;
    private String hoTenNguoiTao; // Thêm tên người tạo
    private String loaiNhom;
    private LocalDateTime ngayTao;
    private LocalDateTime ngayCapNhat;
    // Có thể thêm số lượng thành viên nếu cần query phức tạp hơn
}


/* ===== src\main\java\com\hau\websocket\dto\response\NhomThamGiaResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO trả về thông tin tóm tắt của nhóm mà người dùng tham gia.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NhomThamGiaResponse {
    private Integer nhomId;
    private String tenNhom; // Lấy từ Nhom
    private String anhDaiDienNhom; // Lấy từ Nhom
    private String vaiTroTrongNhom; // Vai trò của người dùng trong nhóm này
}


/* ===== src\main\java\com\hau\websocket\dto\response\NhomThanhVienResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * DTO trả về thông tin chi tiết của một thành viên trong nhóm.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class NhomThanhVienResponse {
    private Integer nhomId;
    private Integer nguoiDungId;
    private String hoTenNguoiDung; // Lấy từ NguoiDung
    private String anhDaiDienNguoiDung; // Lấy từ NguoiDung
    private String vaiTroTrongNhom;
    private LocalDateTime ngayThamGia;
}


/* ===== src\main\java\com\hau\websocket\dto\response\PageResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * DTO chung để chứa dữ liệu trả về dạng phân trang.
 *
 * @param <T> Kiểu dữ liệu của nội dung trong trang (ví dụ: KhoaResponse, NganhResponse).
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PageResponse<T> {
    private List<T> content;        // Danh sách các đối tượng trong trang hiện tại
    private int totalPages;         // Tổng số trang
    private long totalElements;     // Tổng số phần tử
    private int size;               // Kích thước trang (số phần tử mỗi trang)
    private int number;             // Số trang hiện tại (bắt đầu từ 0)
}


/* ===== src\main\java\com\hau\websocket\dto\response\PhongBanResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PhongBanResponse {
    private Integer id;
    private String maPhongBan;
    private String tenPhongBan;
    private String moTa;
    private String emailLienHe;
    private String soDienThoaiLienHe;
    private LocalDateTime ngayTao;
    private LocalDateTime ngayCapNhat;
}


/* ===== src\main\java\com\hau\websocket\dto\response\TinNhanResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TinNhanResponse {
    private Integer id;
    private String cuocTroChuyenId;
    private Integer nguoiGuiId;
    private String hoTenNguoiGui; // Thêm thông tin người gửi
    private Integer nguoiNhanId;
    // private String hoTenNguoiNhan; // Có thể thêm nếu cần
    private String noiDung;
    private String dinhKemUrl;
    private String dinhKemTenGoc;
    private String dinhKemLoai;
    private LocalDateTime thoiGianGui;
}


/* ===== src\main\java\com\hau\websocket\dto\response\TinNhanTrongNhomResponse.java ===== */
package com.hau.websocket.dto.response;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TinNhanTrongNhomResponse {
    private Integer id;
    private Integer nhomId; // ID nhóm tùy chỉnh (nếu có)
    private Integer lopHocId; // ID lớp học (nếu có)
    private Integer nguoiGuiId;
    private String hoTenNguoiGui;
    private String anhDaiDienNguoiGui; // Thêm ảnh đại diện người gửi
    private String noiDung;
    private String dinhKemUrl;
    private String dinhKemTenGoc;
    private String dinhKemLoai;
    private LocalDateTime thoiGianGui;
}


/* ===== src\main\java\com\hau\websocket\entity\CanBoPhongBan.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.sql.Timestamp;

@Builder
@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "can_bo_phong_ban")
public class CanBoPhongBan {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nguoi_dung_id", unique = true, nullable = false) // Maps to nguoi_dung_id, unique constraint
    private NguoiDung nguoiDung;

    @Column(name = "ma_can_bo", unique = true, nullable = false, length = 50)
    private String maCanBo;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "phong_ban_id", nullable = false)
    private PhongBan phongBan;

    @Column(name = "vai_tro_nhan_vien", length = 100)
    private String vaiTroNhanVien;

    @Column(name = "la_dau_moi_lien_lac", nullable = false, columnDefinition = "BOOLEAN DEFAULT false")
    private boolean laDauMoiLienLac = false;

    @CreationTimestamp
    @Column(name = "ngay_tao", nullable = false, updatable = false)
    private Timestamp ngayTao;

    @UpdateTimestamp
    @Column(name = "ngay_cap_nhat", nullable = false)
    private Timestamp ngayCapNhat;
}


/* ===== src\main\java\com\hau\websocket\entity\Khoa.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.sql.Timestamp;
import java.util.Set;

@Builder
@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "khoa")
public class Khoa {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(name = "ma_khoa", unique = true, nullable = false, length = 50)
    private String maKhoa;

    @Column(name = "ten_khoa", nullable = false, length = 255)
    private String tenKhoa;

    @CreationTimestamp
    @Column(name = "ngay_tao", nullable = false, updatable = false)
    private Timestamp ngayTao;

    @UpdateTimestamp
    @Column(name = "ngay_cap_nhat", nullable = false)
    private Timestamp ngayCapNhat;

    @OneToMany(mappedBy = "khoa", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Nganh> nganhs;
}


/* ===== src\main\java\com\hau\websocket\entity\LoaiNguoiDung.java ===== */
package com.hau.websocket.entity;

public enum LoaiNguoiDung {
    SINH_VIEN,      // Changed from SinhVien
    CAN_BO_LOP,     // Changed from CanBoLop
    CAN_BO_PHONG_BAN // Changed from CanBoPhongBan
}


/* ===== src\main\java\com\hau\websocket\entity\LopHoc.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.sql.Timestamp;
import java.util.Set;

@Builder
@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "lop_hoc")
public class LopHoc {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(name = "ma_lop", unique = true, nullable = false, length = 50)
    private String maLop;

    @Column(name = "ten_lop", nullable = false, length = 255)
    private String tenLop;

    @Column(name = "nien_khoa", length = 50)
    private String nienKhoa; // Ví dụ: 2021-2025

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nganh_id", nullable = false)
    private Nganh nganh;

    @CreationTimestamp
    @Column(name = "ngay_tao", nullable = false, updatable = false)
    private Timestamp ngayTao;

    @UpdateTimestamp
    @Column(name = "ngay_cap_nhat", nullable = false)
    private Timestamp ngayCapNhat;

    @OneToMany(mappedBy = "lopHoc", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<SinhVien> sinhViens;

    @OneToMany(mappedBy = "lopHoc", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<TinNhanLop> tinNhanLops;
}


/* ===== src\main\java\com\hau\websocket\entity\Nganh.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.sql.Timestamp;
import java.util.Set;

@Builder
@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "nganh")
public class Nganh {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(name = "ma_nganh", unique = true, nullable = false, length = 50)
    private String maNganh;

    @Column(name = "ten_nganh", nullable = false, length = 255)
    private String tenNganh;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "khoa_id", nullable = false)
    private Khoa khoa;

    @CreationTimestamp
    @Column(name = "ngay_tao", nullable = false, updatable = false)
    private Timestamp ngayTao;

    @UpdateTimestamp
    @Column(name = "ngay_cap_nhat", nullable = false)
    private Timestamp ngayCapNhat;

    @OneToMany(mappedBy = "nganh", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<LopHoc> lopHocs;
}


/* ===== src\main\java\com\hau\websocket\entity\NguoiDung.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.sql.Timestamp;
import java.util.Set;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "nguoi_dung")
public class NguoiDung {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(name = "ma_dang_nhap", unique = true, nullable = false, length = 100)
    private String maDangNhap; // MSV/Mã Cán bộ/Username

    @Column(name = "mat_khau", nullable = false, length = 255)
    private String matKhau; // Hashed password

    @Column(name = "ho_ten", nullable = false, length = 255)
    private String hoTen;

    @Column(name = "email", unique = true, length = 255)
    private String email;

    @Column(name = "so_dien_thoai", length = 20)
    private String soDienThoai;

    @Column(name = "dia_chi", length = 500)
    private String diaChi;

    @Column(name = "anh_dai_dien", length = 500)
    private String anhDaiDien; // URL or path

    @Enumerated(EnumType.STRING) // Store enum name as string
    @Column(name = "loai_tai_khoan", nullable = false)
    private LoaiNguoiDung loaiTaiKhoan;

    @Builder.Default
    @Column(name = "trang_thai", nullable = false, columnDefinition = "BOOLEAN DEFAULT true")
    private boolean trangThai = true; // true: active, false: inactive

    @CreationTimestamp
    @Column(name = "ngay_tao", nullable = false, updatable = false)
    private Timestamp ngayTao;

    @UpdateTimestamp
    @Column(name = "ngay_cap_nhat", nullable = false)
    private Timestamp ngayCapNhat;

    // Relationships
    @OneToOne(mappedBy = "nguoiDung", cascade = CascadeType.ALL, fetch = FetchType.LAZY, optional = true)
    private SinhVien sinhVien;

    @OneToOne(mappedBy = "nguoiDung", cascade = CascadeType.ALL, fetch = FetchType.LAZY, optional = true)
    private CanBoPhongBan canBoPhongBan;

    @OneToMany(mappedBy = "nguoiTao", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<Nhom> danhSachNhomTao;

    @OneToMany(mappedBy = "nguoiDung", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ThanhVienNhom> danhSachThanhVienNhom;

    @OneToMany(mappedBy = "nguoiGui", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<TinNhan> tinNhansGui;

    @OneToMany(mappedBy = "nguoiNhan", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<TinNhan> tinNhansNhan;

    @OneToMany(mappedBy = "nguoiGui", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<TinNhanNhom> tinNhanNhomsGui;

    @OneToMany(mappedBy = "nguoiGui", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<TinNhanLop> tinNhanLopsGui;
}


/* ===== src\main\java\com\hau\websocket\entity\Nhom.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.sql.Timestamp;
import java.util.Set;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "nhom")
public class Nhom {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(name = "ten_nhom", nullable = false, length = 255)
    private String tenNhom;

    @Column(name = "mo_ta", columnDefinition = "TEXT")
    private String moTa;

    @Column(name = "anh_dai_dien_nhom", length = 500)
    private String anhDaiDienNhom;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nguoi_tao_id", nullable = false)
    private NguoiDung nguoiTao;

    @Builder.Default
    @Column(name = "loai_nhom", length = 50, columnDefinition = "VARCHAR(50) DEFAULT 'TuyChinh'")
    private String loaiNhom = "TuyChinh"; // Vd: CLB, DuAn, HocTap

    @CreationTimestamp
    @Column(name = "ngay_tao", nullable = false, updatable = false)
    private Timestamp ngayTao;

    @UpdateTimestamp
    @Column(name = "ngay_cap_nhat", nullable = false)
    private Timestamp ngayCapNhat;

    @OneToMany(mappedBy = "nhom", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<ThanhVienNhom> thanhVienNhoms;

    @OneToMany(mappedBy = "nhom", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<TinNhanNhom> tinNhanNhoms;
}


/* ===== src\main\java\com\hau\websocket\entity\NhomThanhVien.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.sql.Timestamp;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "thanh_vien_nhom") // Mapped to the correct table
// Remove @IdClass annotation if it exists
public class NhomThanhVien { // Keep the class name for now, but it maps to ThanhVienNhom table

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id; // Simple integer primary key

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nhom_id", nullable = false)
    private Nhom nhom;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nguoi_dung_id", nullable = false)
    private NguoiDung nguoiDung;

    @CreationTimestamp
    @Column(name = "ngay_tham_gia", nullable = false, updatable = false)
    private Timestamp ngayThamGia;
}


/* ===== src\main\java\com\hau\websocket\entity\PhongBan.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.sql.Timestamp;
import java.util.Set;

@Builder
@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "phong_ban")
public class PhongBan {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(name = "ma_phong_ban", unique = true, nullable = false, length = 50)
    private String maPhongBan;

    @Column(name = "ten_phong_ban", nullable = false, length = 255)
    private String tenPhongBan;

    @Column(name = "mo_ta", columnDefinition = "TEXT")
    private String moTa;

    @Column(name = "email_lien_he", length = 255)
    private String emailLienHe;

    @Column(name = "so_dien_thoai_lien_he", length = 20)
    private String soDienThoaiLienHe;

    @CreationTimestamp
    @Column(name = "ngay_tao", nullable = false, updatable = false)
    private Timestamp ngayTao;

    @UpdateTimestamp
    @Column(name = "ngay_cap_nhat", nullable = false)
    private Timestamp ngayCapNhat;

    @OneToMany(mappedBy = "phongBan", cascade = CascadeType.ALL, orphanRemoval = true)
    private Set<CanBoPhongBan> canBoPhongBans;
}


/* ===== src\main\java\com\hau\websocket\entity\SinhVien.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.sql.Timestamp;

@Builder
@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "sinh_vien")
public class SinhVien {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Use identity for simple PK
    private Integer id;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nguoi_dung_id", unique = true, nullable = false) // Maps to nguoi_dung_id, unique constraint
    private NguoiDung nguoiDung;

    @Column(name = "ma_sinh_vien", unique = true, nullable = false, length = 50)
    private String maSinhVien;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "lop_hoc_id", nullable = false)
    private LopHoc lopHoc;

    @CreationTimestamp
    @Column(name = "ngay_tao", nullable = false, updatable = false)
    private Timestamp ngayTao;

    @UpdateTimestamp
    @Column(name = "ngay_cap_nhat", nullable = false)
    private Timestamp ngayCapNhat;
}


/* ===== src\main\java\com\hau\websocket\entity\ThanhVienNhom.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.sql.Timestamp;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "thanh_vien_nhom")
public class ThanhVienNhom {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nhom_id", nullable = false)
    private Nhom nhom;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nguoi_dung_id", nullable = false)
    private NguoiDung nguoiDung;

    @CreationTimestamp
    @Column(name = "ngay_tham_gia", nullable = false, updatable = false)
    private Timestamp ngayThamGia;
}


/* ===== src\main\java\com\hau\websocket\entity\TinNhan.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.SQLRestriction;

import java.sql.Timestamp;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "tin_nhan")
@SQLDelete(sql = "UPDATE tin_nhan SET soft_deleted = true WHERE id=?")
@SQLRestriction("soft_deleted=false")
public class TinNhan {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nguoi_gui_id", nullable = false)
    private NguoiDung nguoiGui;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nguoi_nhan_id", nullable = false)
    private NguoiDung nguoiNhan;

    @Column(name = "noi_dung", columnDefinition = "TEXT")
    private String noiDung;

    @Column(name = "dinh_kem_url", length = 500)
    private String dinhKemUrl;

    @Column(name = "dinh_kem_ten_goc_file", length = 255)
    private String dinhKemTenGocFile;

    @Column(name = "dinh_kem_loai", length = 100)
    private String dinhKemLoai; // MIME type

    @CreationTimestamp
    @Column(name = "thoi_gian_gui", nullable = false, updatable = false)
    private Timestamp thoiGianGui;

    @Builder.Default
    @Column(name = "soft_deleted", columnDefinition = "BOOLEAN DEFAULT false")
    private boolean softDeleted = false;
}


/* ===== src\main\java\com\hau\websocket\entity\TinNhanLop.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.sql.Timestamp;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "tin_nhan_lop")
public class TinNhanLop {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "lop_hoc_id", nullable = false)
    private LopHoc lopHoc;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nguoi_gui_id", nullable = false)
    private NguoiDung nguoiGui;

    @Column(name = "noi_dung", columnDefinition = "TEXT")
    private String noiDung;

    @Column(name = "dinh_kem_url", length = 500)
    private String dinhKemUrl;

    @Column(name = "dinh_kem_ten_goc", length = 255)
    private String dinhKemTenGoc;

    @Column(name = "dinh_kem_loai", length = 100)
    private String dinhKemLoai; // MIME type

    @CreationTimestamp
    @Column(name = "thoi_gian_gui", nullable = false, updatable = false)
    private Timestamp thoiGianGui;
}


/* ===== src\main\java\com\hau\websocket\entity\TinNhanNhom.java ===== */
package com.hau.websocket.entity;

import jakarta.persistence.*;
import lombok.*;
import org.hibernate.annotations.CreationTimestamp;

import java.sql.Timestamp;

@Setter
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "tin_nhan_nhom") // Renamed table
public class TinNhanNhom { // Renamed class

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nhom_id", nullable = false) // Changed from tin_nhan_trong_nhom_id
    private Nhom nhom;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "nguoi_gui_id", nullable = false)
    private NguoiDung nguoiGui;

    @Column(name = "noi_dung", columnDefinition = "TEXT")
    private String noiDung;

    @Column(name = "dinh_kem_url", length = 500)
    private String dinhKemUrl;

    @Column(name = "dinh_kem_ten_goc", length = 255) // Renamed column
    private String dinhKemTenGoc;

    @Column(name = "dinh_kem_loai", length = 100)
    private String dinhKemLoai; // MIME type

    @CreationTimestamp
    @Column(name = "thoi_gian_gui", nullable = false, updatable = false)
    private Timestamp thoiGianGui;
}


/* ===== src\main\java\com\hau\websocket\exception\AppException.java ===== */
package com.hau.websocket.exception;

import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpStatus;

import java.time.LocalDateTime;

@Setter
@Getter
public class AppException extends RuntimeException {
    private final HttpStatus httpStatus;
    private final transient Object error;
    private final LocalDateTime timestamp;

    public AppException(HttpStatus httpStatus, String message, Object error) {
        super(message);
        this.httpStatus = httpStatus;
        this.error = error;
        this.timestamp = LocalDateTime.now();
    }
}


/* ===== src\main\java\com\hau\websocket\exception\GlobalExceptionHandler.java ===== */
package com.hau.websocket.exception;

import com.hau.websocket.dto.response.ErrorsResponse;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {
    // Xử lý ngoại lệ validation
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorsResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> {
            Map<String, String> detail = new HashMap<>();
            detail.put("field", error.getField());
            detail.put("message", error.getDefaultMessage());
            errorDetails.add(detail);
        });
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Lỗi trường dữ liệu", errorDetails, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ DataIntegrityViolationException
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ErrorsResponse> handleDataIntegrityViolation(DataIntegrityViolationException ex) {
        List<Map<String, String>> errorDetails = new ArrayList<>();
        Map<String, String> detail = new HashMap<>();
        detail.put("error", ex.getMessage());
        errorDetails.add(detail);
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Vi phạm tính toàn vẹn dữ liệu. Xem 'error' để biết chi tiết.",
                errorDetails,
                LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý ngoại lệ tham số không đúng định dạng trong url
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ErrorsResponse> handleMethodArgumentTypeMismatch(MethodArgumentTypeMismatchException ex) {
        String name = ex.getName();
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Tham số " + name + " không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi truyền sai định dạng tham số trong body request
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ErrorsResponse> handleHttpMessageNotReadableException() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.BAD_REQUEST.value(), "Dữ liệu request không đúng định dạng", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
    }

    // Xử lý lỗi khi không tìm thấy tài nguyên
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorsResponse> handleAppException(AppException ex) {
        ErrorsResponse errorResponse =
                new ErrorsResponse(ex.getHttpStatus().value(), ex.getMessage(), ex.getError(), LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, ex.getHttpStatus()); // Trả về HttpStatus từ AppException
    }

    // Xử lý tất cả các ngoại lệ chưa được xác định
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorsResponse> handleAllExceptions() {
        ErrorsResponse errorResponse = new ErrorsResponse(
                HttpStatus.INTERNAL_SERVER_ERROR.value(), "Đã có lỗi xảy ra(chưa xác định)", null, LocalDateTime.now());
        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}


/* ===== src\main\java\com\hau\websocket\mapper\KhoaMapper.java ===== */
package com.hau.websocket.mapper;

import com.hau.websocket.dto.request.KhoaCreate;
import com.hau.websocket.dto.request.KhoaUpdate;
import com.hau.websocket.dto.response.KhoaResponse;
import com.hau.websocket.entity.Khoa;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE) // Bỏ qua các trường không map
public interface KhoaMapper {

    /**
     * Chuyển đổi từ KhoaCreate DTO sang Khoa Entity.
     *
     * @param khoaCreate DTO chứa thông tin tạo mới.
     * @return Khoa Entity.
     */
    Khoa toKhoa(KhoaCreate khoaCreate);

    /**
     * Cập nhật thông tin từ KhoaUpdate DTO vào Khoa Entity đã tồn tại.
     *
     * @param khoa       Entity Khoa cần cập nhật (được lấy từ DB).
     * @param khoaUpdate DTO chứa thông tin cập nhật.
     */
    void updateKhoa(@MappingTarget Khoa khoa, KhoaUpdate khoaUpdate);

    /**
     * Chuyển đổi từ Khoa Entity sang KhoaResponse DTO.
     *
     * @param khoa Entity Khoa.
     * @return KhoaResponse DTO.
     */
    KhoaResponse toKhoaResponse(Khoa khoa);

}


/* ===== src\main\java\com\hau\websocket\mapper\LopHocMapper.java ===== */
package com.hau.websocket.mapper;

import com.hau.websocket.dto.request.LopHocCreate;
import com.hau.websocket.dto.request.LopHocUpdate;
import com.hau.websocket.dto.response.LopHocResponse;
import com.hau.websocket.entity.LopHoc;
import org.mapstruct.*;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface LopHocMapper {

    @Mapping(target = "nganh", ignore = true)
        // Sẽ set Nganh object trong Service
    LopHoc toLopHoc(LopHocCreate lopHocCreate);

    @Mapping(target = "nganh", ignore = true)
        // Sẽ set Nganh object trong Service nếu cần
    void updateLopHoc(@MappingTarget LopHoc lopHoc, LopHocUpdate lopHocUpdate);

    @Mapping(source = "nganh.id", target = "nganhId")
    @Mapping(source = "nganh.tenNganh", target = "tenNganh")
    LopHocResponse toLopHocResponse(LopHoc lopHoc);

}


/* ===== src\main\java\com\hau\websocket\mapper\NganhMapper.java ===== */
package com.hau.websocket.mapper;

import com.hau.websocket.dto.request.NganhCreate;
import com.hau.websocket.dto.request.NganhUpdate;
import com.hau.websocket.dto.response.NganhResponse;
import com.hau.websocket.entity.Nganh;
import org.mapstruct.*;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface NganhMapper {

    // Map Create DTO -> Entity (Không map khoaId trực tiếp vào object Khoa)
    @Mapping(target = "khoa", ignore = true)
    // Sẽ set Khoa object trong Service
    Nganh toNganh(NganhCreate nganhCreate);

    // Map Update DTO -> Entity (Không map khoaId trực tiếp vào object Khoa)
    @Mapping(target = "khoa", ignore = true)
    // Sẽ set Khoa object trong Service nếu cần
    void updateNganh(@MappingTarget Nganh nganh, NganhUpdate nganhUpdate);

    // Map Entity -> Response DTO (Lấy thông tin từ object Khoa liên quan)
    @Mapping(source = "khoa.id", target = "khoaId")
    @Mapping(source = "khoa.tenKhoa", target = "tenKhoa")
    NganhResponse toNganhResponse(Nganh nganh);

}


/* ===== src\main\java\com\hau\websocket\mapper\NguoiDungMapper.java ===== */
package com.hau.websocket.mapper;

import com.hau.websocket.dto.request.NguoiDungCreate;
import com.hau.websocket.dto.request.NguoiDungUpdate;
import com.hau.websocket.dto.response.NguoiDungResponse;
import com.hau.websocket.entity.NguoiDung;
import org.mapstruct.*;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface NguoiDungMapper {

    @Mapping(target = "matKhau", ignore = true) // Mật khẩu sẽ được hash trong Service
    @Mapping(target = "lopHoc", ignore = true)  // Sẽ set trong Service
    @Mapping(target = "phongBan", ignore = true) // Sẽ set trong Service
    @Mapping(target = "trangThai", ignore = true)
        // Sẽ set mặc định trong Service
    NguoiDung toNguoiDung(NguoiDungCreate nguoiDungCreate);

    @Mapping(target = "lopHoc", ignore = true)  // Sẽ set trong Service nếu thay đổi
    @Mapping(target = "phongBan", ignore = true)
        // Sẽ set trong Service nếu thay đổi
    void updateNguoiDung(@MappingTarget NguoiDung nguoiDung, NguoiDungUpdate nguoiDungUpdate);

    @Mapping(source = "lopHoc.id", target = "lopHocId")
    @Mapping(source = "lopHoc.tenLop", target = "tenLopHoc")
    @Mapping(source = "phongBan.id", target = "phongBanId")
    @Mapping(source = "phongBan.tenPhongBan", target = "tenPhongBan")
    NguoiDungResponse toNguoiDungResponse(NguoiDung nguoiDung);

}


/* ===== src\main\java\com\hau\websocket\mapper\NhomMapper.java ===== */
package com.hau.websocket.mapper;

import com.hau.websocket.dto.request.NhomCreate;
import com.hau.websocket.dto.request.NhomUpdate;
import com.hau.websocket.dto.response.NhomResponse;
import com.hau.websocket.entity.Nhom;
import org.mapstruct.*;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface NhomMapper {

    @Mapping(target = "nguoiTao", ignore = true) // Set trong Service
    @Mapping(target = "loaiNhom", ignore = true)
        // Xử lý default trong Service
    Nhom toNhom(NhomCreate nhomCreate);

    void updateNhom(@MappingTarget Nhom nhom, NhomUpdate nhomUpdate);

    @Mapping(source = "nguoiTao.id", target = "nguoiTaoId")
    @Mapping(source = "nguoiTao.hoTen", target = "hoTenNguoiTao")
    NhomResponse toNhomResponse(Nhom nhom);

}


/* ===== src\main\java\com\hau\websocket\mapper\NhomThanhVienMapper.java ===== */
package com.hau.websocket.mapper;

// import com.hau.websocket.dto.request.NhomThanhVienAddRequest; // Không cần map trực tiếp từ Add DTO

import com.hau.websocket.dto.response.NhomThamGiaResponse;
import com.hau.websocket.dto.response.NhomThanhVienResponse;
import com.hau.websocket.entity.NhomThanhVien;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface NhomThanhVienMapper {

    @Mapping(source = "id.nhomId", target = "nhomId") // Map từ composite key
    @Mapping(source = "id.nguoiDungId", target = "nguoiDungId") // Map từ composite key
    @Mapping(source = "nguoiDung.hoTen", target = "hoTenNguoiDung")
    @Mapping(source = "nguoiDung.anhDaiDien", target = "anhDaiDienNguoiDung")
    NhomThanhVienResponse toNhomThanhVienResponse(NhomThanhVien nhomThanhVien);

    @Mapping(source = "id.nhomId", target = "nhomId") // Map từ composite key
    @Mapping(source = "nhom.tenNhom", target = "tenNhom")
    @Mapping(source = "nhom.anhDaiDienNhom", target = "anhDaiDienNhom")
    NhomThamGiaResponse toNhomThamGiaResponse(NhomThanhVien nhomThanhVien);

}


/* ===== src\main\java\com\hau\websocket\mapper\PhongBanMapper.java ===== */
package com.hau.websocket.mapper;

import com.hau.websocket.dto.request.PhongBanCreate;
import com.hau.websocket.dto.request.PhongBanUpdate;
import com.hau.websocket.dto.response.PhongBanResponse;
import com.hau.websocket.entity.PhongBan;
import org.mapstruct.Mapper;
import org.mapstruct.MappingTarget;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface PhongBanMapper {

    PhongBan toPhongBan(PhongBanCreate phongBanCreate);

    void updatePhongBan(@MappingTarget PhongBan phongBan, PhongBanUpdate phongBanUpdate);

    PhongBanResponse toPhongBanResponse(PhongBan phongBan);

}


/* ===== src\main\java\com\hau\websocket\mapper\TinNhanMapper.java ===== */
package com.hau.websocket.mapper;

import com.hau.websocket.dto.request.TinNhanCreate;
import com.hau.websocket.dto.response.TinNhanResponse;
import com.hau.websocket.entity.TinNhan;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface TinNhanMapper {

    @Mapping(target = "nguoiGui", ignore = true) // Set trong Service
    @Mapping(target = "nguoiNhan", ignore = true) // Set trong Service
    @Mapping(target = "thoiGianGui", ignore = true)
        // Set tự động hoặc trong Service
    TinNhan toTinNhan(TinNhanCreate tinNhanCreate);

    @Mapping(source = "nguoiGui.id", target = "nguoiGuiId")
    @Mapping(source = "nguoiGui.hoTen", target = "hoTenNguoiGui") // Lấy họ tên người gửi
    @Mapping(source = "nguoiNhan.id", target = "nguoiNhanId")
        // @Mapping(source = "nguoiNhan.hoTen", target = "hoTenNguoiNhan") // Nếu cần tên người nhận
    TinNhanResponse toTinNhanResponse(TinNhan tinNhan);

}


/* ===== src\main\java\com\hau\websocket\mapper\TinNhanTrongNhomMapper.java ===== */
package com.hau.websocket.mapper;

import com.hau.websocket.dto.request.TinNhanTrongNhomCreate;
import com.hau.websocket.dto.response.TinNhanTrongNhomResponse;
import com.hau.websocket.entity.TinNhanTrongNhom;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface TinNhanTrongNhomMapper {

    @Mapping(target = "nhom", ignore = true)     // Set trong Service
    @Mapping(target = "lopHoc", ignore = true)  // Set trong Service
    @Mapping(target = "nguoiGui", ignore = true) // Set trong Service
    @Mapping(target = "thoiGianGui", ignore = true)
    TinNhanTrongNhom toTinNhanTrongNhom(TinNhanTrongNhomCreate createDto);

    @Mapping(source = "nhom.id", target = "nhomId") // Lấy ID từ Nhom entity (có thể null)
    @Mapping(source = "lopHoc.id", target = "lopHocId") // Lấy ID từ LopHoc entity (có thể null)
    @Mapping(source = "nguoiGui.id", target = "nguoiGuiId")
    @Mapping(source = "nguoiGui.hoTen", target = "hoTenNguoiGui")
    @Mapping(source = "nguoiGui.anhDaiDien", target = "anhDaiDienNguoiGui")
    TinNhanTrongNhomResponse toTinNhanTrongNhomResponse(TinNhanTrongNhom tinNhan);

}


/* ===== src\main\java\com\hau\websocket\repository\KhoaRepository.java ===== */
package com.hau.websocket.repository;

import com.hau.websocket.entity.Khoa;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface KhoaRepository extends JpaRepository<Khoa, Integer> { // Kiểu ID là Integer

    /**
     * Tìm kiếm Khoa dựa trên mã khoa.
     * Dùng để kiểm tra tính duy nhất của mã khoa.
     *
     * @param maKhoa Mã khoa cần tìm.
     * @return Optional chứa Khoa nếu tìm thấy, ngược lại là Optional rỗng.
     */
    Optional<Khoa> findByMaKhoa(String maKhoa);
}


/* ===== src\main\java\com\hau\websocket\repository\LopHocRepository.java ===== */
package com.hau.websocket.repository;

import com.hau.websocket.entity.LopHoc;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface LopHocRepository extends JpaRepository<LopHoc, Integer> {

    /**
     * Tìm Lớp học theo mã lớp (kiểm tra unique).
     */
    Optional<LopHoc> findByMaLop(String maLop);
}


/* ===== src\main\java\com\hau\websocket\repository\NganhRepository.java ===== */
package com.hau.websocket.repository;

import com.hau.websocket.entity.Nganh;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface NganhRepository extends JpaRepository<Nganh, Integer> {

    /**
     * Tìm Ngành theo mã ngành (kiểm tra unique).
     */
    Optional<Nganh> findByMaNganh(String maNganh);
}


/* ===== src\main\java\com\hau\websocket\repository\NguoiDungRepository.java ===== */
package com.hau.websocket.repository;

import com.hau.websocket.entity.NguoiDung;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface NguoiDungRepository extends JpaRepository<NguoiDung, Integer> {

    Optional<NguoiDung> findByMaDangNhap(String maDangNhap);

    Optional<NguoiDung> findByEmail(String email);

    Optional<NguoiDung> findByMaSinhVien(String maSinhVien);

    Optional<NguoiDung> findByMaCanBo(String maCanBo);
}


/* ===== src\main\java\com\hau\websocket\repository\NhomRepository.java ===== */
package com.hau.websocket.repository;

import com.hau.websocket.entity.Nhom;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

// Có thể thêm các phương thức tìm kiếm tùy chỉnh nếu cần, ví dụ:
// Page<Nhom> findByNguoiTaoId(Integer nguoiTaoId, Pageable pageable);
// Page<Nhom> findByTenNhomContainingIgnoreCase(String tenNhom, Pageable pageable);

@Repository
public interface NhomRepository extends JpaRepository<Nhom, Integer> {
}


/* ===== src\main\java\com\hau\websocket\repository\NhomThanhVienRepository.java ===== */
package com.hau.websocket.repository;

import com.hau.websocket.entity.NhomThanhVien;
import com.hau.websocket.entity.NhomThanhVienId;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional; // Import nếu dùng @Transactional

import java.util.Optional;

@Repository
public interface NhomThanhVienRepository extends JpaRepository<NhomThanhVien, NhomThanhVienId> {

    /**
     * Tìm danh sách thành viên của một nhóm (phân trang).
     */
    Page<NhomThanhVien> findById_NhomId(Integer nhomId, Pageable pageable);
    // Hoặc cách khác tường minh hơn:
    // Page<NhomThanhVien> findByNhom_Id(Integer nhomId, Pageable pageable);


    /**
     * Tìm danh sách các nhóm mà một người dùng tham gia (phân trang).
     */
    Page<NhomThanhVien> findById_NguoiDungId(Integer nguoiDungId, Pageable pageable);
    // Hoặc cách khác tường minh hơn:
    // Page<NhomThanhVien> findByNguoiDung_Id(Integer nguoiDungId, Pageable pageable);

    /**
     * Tìm một bản ghi thành viên cụ thể bằng ID nhóm và ID người dùng.
     */
    Optional<NhomThanhVien> findById_NhomIdAndId_NguoiDungId(Integer nhomId, Integer nguoiDungId);
    // Hoặc cách khác tường minh hơn:
    // Optional<NhomThanhVien> findByNhom_IdAndNguoiDung_Id(Integer nhomId, Integer nguoiDungId);


    /**
     * Xóa tất cả thành viên của một nhóm (hữu ích khi xóa nhóm).
     */
    @Transactional // Cần Transactional cho các thao tác delete/update tùy chỉnh
    void deleteById_NhomId(Integer nhomId);
    // Hoặc cách khác tường minh hơn:
    // void deleteByNhom_Id(Integer nhomId);

}


/* ===== src\main\java\com\hau\websocket\repository\PhongBanRepository.java ===== */
package com.hau.websocket.repository;

import com.hau.websocket.entity.PhongBan;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface PhongBanRepository extends JpaRepository<PhongBan, Integer> {

    /**
     * Tìm Phòng ban theo mã phòng ban (kiểm tra unique).
     */
    Optional<PhongBan> findByMaPhongBan(String maPhongBan);
}


/* ===== src\main\java\com\hau\websocket\repository\TinNhanRepository.java ===== */
package com.hau.websocket.repository;

import com.hau.websocket.entity.TinNhan;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TinNhanRepository extends JpaRepository<TinNhan, Integer> {

    /**
     * Tìm kiếm tin nhắn theo ID cuộc trò chuyện, sắp xếp theo thời gian gửi giảm dần (mới nhất trước).
     * Hỗ trợ phân trang.
     */
    Page<TinNhan> findByCuocTroChuyenIdOrderByThoiGianGuiDesc(String cuocTroChuyenId, Pageable pageable);

    /**
     * Tìm kiếm tin nhắn theo ID cuộc trò chuyện, sắp xếp theo thời gian gửi tăng dần (cũ nhất trước).
     * Hỗ trợ phân trang.
     */
    // Optional: findByCuocTroChuyenIdOrderByThoiGianGuiAsc(String cuocTroChuyenId, Pageable pageable);

}


/* ===== src\main\java\com\hau\websocket\repository\TinNhanTrongNhomRepository.java ===== */
package com.hau.websocket.repository;

import com.hau.websocket.entity.TinNhanTrongNhom;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TinNhanTrongNhomRepository extends JpaRepository<TinNhanTrongNhom, Integer> {

    /**
     * Tìm tin nhắn theo ID nhóm tùy chỉnh, sắp xếp theo thời gian gửi giảm dần.
     */
    Page<TinNhanTrongNhom> findByNhomIdOrderByThoiGianGuiDesc(Integer nhomId, Pageable pageable);

    /**
     * Tìm tin nhắn theo ID lớp học, sắp xếp theo thời gian gửi giảm dần.
     */
    Page<TinNhanTrongNhom> findByLopHocIdOrderByThoiGianGuiDesc(Integer lopHocId, Pageable pageable);

    // Có thể thêm các phương thức xóa nếu cần (ví dụ: khi xóa nhóm/lớp)
    // void deleteByNhomId(Integer nhomId);
    // void deleteByLopHocId(Integer lopHocId);
}


/* ===== src\main\java\com\hau\websocket\service\KhoaService.java ===== */
package com.hau.websocket.service;

import com.hau.websocket.dto.request.KhoaCreate;
import com.hau.websocket.dto.request.KhoaUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.KhoaResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.entity.Khoa;
import com.hau.websocket.exception.AppException;
import com.hau.websocket.mapper.KhoaMapper;
import com.hau.websocket.repository.KhoaRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional; // Import Transactional

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor // Tự động inject dependencies qua constructor
@Slf4j // Logging
public class KhoaService {

    private final KhoaRepository khoaRepository;
    private final KhoaMapper khoaMapper;

    /**
     * Tạo mới một Khoa.
     *
     * @param khoaCreate DTO chứa thông tin Khoa cần tạo.
     * @return ApiResponse chứa thông tin Khoa đã tạo.
     * @throws AppException Nếu mã khoa đã tồn tại.
     */
    @Transactional // Đảm bảo tính toàn vẹn dữ liệu
    public ApiResponse<KhoaResponse> createKhoa(KhoaCreate khoaCreate) {
        log.info("Bắt đầu tạo Khoa với mã: {}", khoaCreate.getMaKhoa());

        // 1. Kiểm tra trùng mã khoa
        khoaRepository.findByMaKhoa(khoaCreate.getMaKhoa()).ifPresent(existingKhoa -> {
            log.warn("Mã khoa '{}' đã tồn tại.", khoaCreate.getMaKhoa());
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã khoa đã tồn tại", null);
        });

        // 2. Map DTO -> Entity
        Khoa khoa = khoaMapper.toKhoa(khoaCreate);

        // 3. Lưu vào DB
        try {
            Khoa savedKhoa = khoaRepository.save(khoa);
            log.info("Đã tạo Khoa thành công với ID: {}", savedKhoa.getId());

            // 4. Map Entity -> Response DTO
            KhoaResponse khoaResponse = khoaMapper.toKhoaResponse(savedKhoa);

            // 5. Trả về kết quả
            return ApiResponse.<KhoaResponse>builder().status(HttpStatus.CREATED.value()).message("Tạo mới khoa thành công").result(khoaResponse).timestamp(LocalDateTime.now()).build();
        } catch (DataIntegrityViolationException e) {
            // Bắt lỗi nếu DB constraint báo lỗi (ví dụ: unique constraint dù đã check)
            log.error("Lỗi DataIntegrityViolationException khi tạo Khoa: {}", e.getMessage());
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi tạo khoa, có thể do trùng mã khoa.", null);
        }
    }

    /**
     * Cập nhật thông tin Khoa.
     *
     * @param id         ID của Khoa cần cập nhật.
     * @param khoaUpdate DTO chứa thông tin cập nhật.
     * @return ApiResponse chứa thông tin Khoa sau khi cập nhật.
     * @throws AppException Nếu không tìm thấy Khoa.
     */
    @Transactional
    public ApiResponse<KhoaResponse> updateKhoa(Integer id, KhoaUpdate khoaUpdate) {
        log.info("Bắt đầu cập nhật Khoa với ID: {}", id);

        // 1. Tìm Khoa cần cập nhật
        Khoa existingKhoa = findByIdHelper(id);

        // 2. Cập nhật thông tin từ DTO vào Entity
        khoaMapper.updateKhoa(existingKhoa, khoaUpdate); // Chỉ cập nhật các trường có trong DTO

        // 3. Lưu thay đổi
        try {
            Khoa updatedKhoa = khoaRepository.save(existingKhoa);
            log.info("Đã cập nhật Khoa thành công với ID: {}", updatedKhoa.getId());

            // 4. Map Entity -> Response DTO
            KhoaResponse khoaResponse = khoaMapper.toKhoaResponse(updatedKhoa);

            // 5. Trả về kết quả
            return ApiResponse.<KhoaResponse>builder().status(HttpStatus.OK.value()).message("Cập nhật khoa thành công").result(khoaResponse).timestamp(LocalDateTime.now()).build();
        } catch (DataIntegrityViolationException e) {
            log.error("Lỗi DataIntegrityViolationException khi cập nhật Khoa: {}", e.getMessage());
            // Lỗi này ít xảy ra khi update nếu không sửa trường unique
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi cập nhật khoa.", null);
        }
    }

    /**
     * Lấy thông tin một Khoa theo ID.
     *
     * @param id ID của Khoa cần lấy.
     * @return ApiResponse chứa thông tin Khoa.
     * @throws AppException Nếu không tìm thấy Khoa.
     */
    public ApiResponse<KhoaResponse> getKhoaById(Integer id) {
        log.info("Bắt đầu lấy thông tin Khoa với ID: {}", id);
        Khoa khoa = findByIdHelper(id);
        KhoaResponse khoaResponse = khoaMapper.toKhoaResponse(khoa);
        log.info("Lấy thông tin Khoa thành công với ID: {}", id);
        return ApiResponse.<KhoaResponse>builder().status(HttpStatus.OK.value()).message("Lấy thông tin khoa thành công").result(khoaResponse).timestamp(LocalDateTime.now()).build();
    }

    /**
     * Xóa một Khoa theo ID.
     *
     * @param id ID của Khoa cần xóa.
     * @return ApiResponse chứa thông báo thành công.
     * @throws AppException Nếu không tìm thấy Khoa.
     */
    @Transactional
    public ApiResponse<String> deleteKhoa(Integer id) {
        log.info("Bắt đầu xóa Khoa với ID: {}", id);
        Khoa khoa = findByIdHelper(id); // Kiểm tra tồn tại trước khi xóa
        khoaRepository.delete(khoa);
        log.info("Đã xóa Khoa thành công với ID: {}", id);
        return ApiResponse.<String>builder().status(HttpStatus.OK.value()).message("Xóa khoa thành công").result(null) // Không có dữ liệu trả về sau khi xóa
                .timestamp(LocalDateTime.now()).build();
    }

    /**
     * Lấy danh sách tất cả các Khoa (có phân trang).
     *
     * @param pageable Đối tượng chứa thông tin phân trang (page, size, sort).
     * @return PageResponse chứa danh sách KhoaResponse và thông tin phân trang.
     */
    public PageResponse<KhoaResponse> getAllKhoa(Pageable pageable) {
        log.info("Bắt đầu lấy danh sách Khoa với thông tin phân trang: {}", pageable);
        Page<Khoa> khoaPage = khoaRepository.findAll(pageable);

        // Chuyển đổi Page<Khoa> sang Page<KhoaResponse>
        Page<KhoaResponse> khoaResponsePage = khoaPage.map(khoaMapper::toKhoaResponse);
        log.info("Lấy danh sách Khoa thành công. Tổng số phần tử: {}, Tổng số trang: {}", khoaResponsePage.getTotalElements(), khoaResponsePage.getTotalPages());

        // Tạo đối tượng PageResponse
        return PageResponse.<KhoaResponse>builder().content(khoaResponsePage.getContent()).totalPages(khoaResponsePage.getTotalPages()).totalElements(khoaResponsePage.getTotalElements()).size(khoaResponsePage.getSize()).number(khoaResponsePage.getNumber()).build();
    }

    /**
     * Hàm hỗ trợ tìm Khoa theo ID, ném AppException nếu không tìm thấy.
     *
     * @param id ID của Khoa cần tìm.
     * @return Khoa Entity nếu tìm thấy.
     * @throws AppException Nếu không tìm thấy Khoa.
     */
    private Khoa findByIdHelper(Integer id) {
        return khoaRepository.findById(id).orElseThrow(() -> {
            log.warn("Không tìm thấy Khoa với ID: {}", id);
            return new AppException(HttpStatus.BAD_REQUEST, "Không tìm thấy Khoa với id: " + id, null);
        });
    }
}


/* ===== src\main\java\com\hau\websocket\service\LopHocService.java ===== */
package com.hau.websocket.service;

import com.hau.websocket.dto.request.LopHocCreate;
import com.hau.websocket.dto.request.LopHocUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.LopHocResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.entity.LopHoc;
import com.hau.websocket.entity.Nganh;
import com.hau.websocket.exception.AppException;
import com.hau.websocket.mapper.LopHocMapper;
import com.hau.websocket.repository.LopHocRepository;
import com.hau.websocket.repository.NganhRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
@Slf4j
public class LopHocService {

    private final LopHocRepository lopHocRepository;
    private final LopHocMapper lopHocMapper;
    private final NganhRepository nganhRepository; // Inject NganhRepository

    @Transactional
    public ApiResponse<LopHocResponse> createLopHoc(LopHocCreate lopHocCreate) {
        log.info("Creating LopHoc with code: {}", lopHocCreate.getMaLop());

        lopHocRepository.findByMaLop(lopHocCreate.getMaLop()).ifPresent(existing -> {
            log.warn("Ma lop '{}' already exists.", lopHocCreate.getMaLop());
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã lớp đã tồn tại", null);
        });

        Nganh nganh = nganhRepository.findById(lopHocCreate.getNganhId())
                .orElseThrow(() -> {
                    log.warn("Nganh with ID {} not found.", lopHocCreate.getNganhId());
                    return new AppException(HttpStatus.BAD_REQUEST, "Ngành không tồn tại", null);
                });

        LopHoc lopHoc = lopHocMapper.toLopHoc(lopHocCreate);
        lopHoc.setNganh(nganh); // Set Nganh entity

        try {
            LopHoc savedLopHoc = lopHocRepository.save(lopHoc);
            log.info("Successfully created LopHoc with ID: {}", savedLopHoc.getId());
            LopHocResponse responseDto = lopHocMapper.toLopHocResponse(savedLopHoc);
            return ApiResponse.<LopHocResponse>builder()
                    .status(HttpStatus.CREATED.value())
                    .message("Tạo mới lớp học thành công")
                    .result(responseDto)
                    .timestamp(LocalDateTime.now())
                    .build();
        } catch (DataIntegrityViolationException e) {
            log.error("DataIntegrityViolationException while creating LopHoc: {}", e.getMessage());
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi tạo lớp học, có thể do trùng mã lớp.", null);
        }
    }

    @Transactional
    public ApiResponse<LopHocResponse> updateLopHoc(Integer id, LopHocUpdate lopHocUpdate) {
        log.info("Updating LopHoc with ID: {}", id);
        LopHoc existingLopHoc = findByIdHelper(id);

        Nganh nganh = existingLopHoc.getNganh();
        if (!lopHocUpdate.getNganhId().equals(nganh.getId())) {
            nganh = nganhRepository.findById(lopHocUpdate.getNganhId())
                    .orElseThrow(() -> {
                        log.warn("Nganh with ID {} not found for update.", lopHocUpdate.getNganhId());
                        return new AppException(HttpStatus.BAD_REQUEST, "Ngành không tồn tại", null);
                    });
        }

        lopHocMapper.updateLopHoc(existingLopHoc, lopHocUpdate);
        existingLopHoc.setNganh(nganh);

        try {
            LopHoc updatedLopHoc = lopHocRepository.save(existingLopHoc);
            log.info("Successfully updated LopHoc with ID: {}", updatedLopHoc.getId());
            LopHocResponse responseDto = lopHocMapper.toLopHocResponse(updatedLopHoc);
            return ApiResponse.<LopHocResponse>builder()
                    .status(HttpStatus.OK.value())
                    .message("Cập nhật lớp học thành công")
                    .result(responseDto)
                    .timestamp(LocalDateTime.now())
                    .build();
        } catch (DataIntegrityViolationException e) {
            log.error("DataIntegrityViolationException while updating LopHoc: {}", e.getMessage());
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi cập nhật lớp học.", null);
        }
    }

    public ApiResponse<LopHocResponse> getLopHocById(Integer id) {
        log.info("Fetching LopHoc with ID: {}", id);
        LopHoc lopHoc = findByIdHelper(id);
        LopHocResponse responseDto = lopHocMapper.toLopHocResponse(lopHoc);
        log.info("Successfully fetched LopHoc with ID: {}", id);
        return ApiResponse.<LopHocResponse>builder()
                .status(HttpStatus.OK.value())
                .message("Lấy thông tin lớp học thành công")
                .result(responseDto)
                .timestamp(LocalDateTime.now())
                .build();
    }

    @Transactional
    public ApiResponse<String> deleteLopHoc(Integer id) {
        log.info("Deleting LopHoc with ID: {}", id);
        LopHoc lopHoc = findByIdHelper(id); // Check existence
        lopHocRepository.delete(lopHoc);
        log.info("Successfully deleted LopHoc with ID: {}", id);
        return ApiResponse.<String>builder()
                .status(HttpStatus.OK.value())
                .message("Xóa lớp học thành công")
                .result(null)
                .timestamp(LocalDateTime.now())
                .build();
    }

    public PageResponse<LopHocResponse> getAllLopHoc(Pageable pageable) {
        log.info("Fetching LopHoc list with pagination: {}", pageable);
        Page<LopHoc> lopHocPage = lopHocRepository.findAll(pageable);
        Page<LopHocResponse> responsePage = lopHocPage.map(lopHocMapper::toLopHocResponse);
        log.info("Successfully fetched LopHoc list. Total elements: {}, Total pages: {}",
                responsePage.getTotalElements(), responsePage.getTotalPages());

        return PageResponse.<LopHocResponse>builder()
                .content(responsePage.getContent())
                .totalPages(responsePage.getTotalPages())
                .totalElements(responsePage.getTotalElements())
                .size(responsePage.getSize())
                .number(responsePage.getNumber())
                .build();
    }

    // Helper method
    private LopHoc findByIdHelper(Integer id) {
        return lopHocRepository.findById(id)
                .orElseThrow(() -> {
                    log.warn("LopHoc with ID {} not found.", id);
                    return new AppException(HttpStatus.BAD_REQUEST, "Không tìm thấy Lớp học với id: " + id, null);
                });
    }
}


/* ===== src\main\java\com\hau\websocket\service\NganhService.java ===== */
package com.hau.websocket.service;

import com.hau.websocket.dto.request.NganhCreate;
import com.hau.websocket.dto.request.NganhUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.NganhResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.entity.Khoa;
import com.hau.websocket.entity.Nganh;
import com.hau.websocket.exception.AppException;
import com.hau.websocket.mapper.NganhMapper;
import com.hau.websocket.repository.KhoaRepository;
import com.hau.websocket.repository.NganhRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
@Slf4j
public class NganhService {

    private final NganhRepository nganhRepository;
    private final NganhMapper nganhMapper;
    private final KhoaRepository khoaRepository; // Inject KhoaRepository để tìm Khoa

    @Transactional
    public ApiResponse<NganhResponse> createNganh(NganhCreate nganhCreate) {
        log.info("Creating Nganh with code: {}", nganhCreate.getMaNganh());

        nganhRepository.findByMaNganh(nganhCreate.getMaNganh()).ifPresent(existing -> {
            log.warn("Ma nganh '{}' already exists.", nganhCreate.getMaNganh());
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã ngành đã tồn tại", null);
        });

        // Tìm Khoa tương ứng
        Khoa khoa = khoaRepository.findById(nganhCreate.getKhoaId()).orElseThrow(() -> {
            log.warn("Khoa with ID {} not found.", nganhCreate.getKhoaId());
            return new AppException(HttpStatus.BAD_REQUEST, "Khoa không tồn tại", null);
        });

        Nganh nganh = nganhMapper.toNganh(nganhCreate);
        nganh.setKhoa(khoa); // Set Khoa entity đã tìm được

        try {
            Nganh savedNganh = nganhRepository.save(nganh);
            log.info("Successfully created Nganh with ID: {}", savedNganh.getId());
            NganhResponse responseDto = nganhMapper.toNganhResponse(savedNganh);
            return ApiResponse.<NganhResponse>builder().status(HttpStatus.CREATED.value()).message("Tạo mới ngành thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
        } catch (DataIntegrityViolationException e) {
            log.error("DataIntegrityViolationException while creating Nganh: {}", e.getMessage());
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi tạo ngành, có thể do trùng mã ngành.", null);
        }
    }

    @Transactional
    public ApiResponse<NganhResponse> updateNganh(Integer id, NganhUpdate nganhUpdate) {
        log.info("Updating Nganh with ID: {}", id);
        Nganh existingNganh = findByIdHelper(id);

        // Kiểm tra và lấy Khoa mới nếu ID Khoa thay đổi
        Khoa khoa = existingNganh.getKhoa(); // Khoa hiện tại
        if (!nganhUpdate.getKhoaId().equals(khoa.getId())) {
            khoa = khoaRepository.findById(nganhUpdate.getKhoaId()).orElseThrow(() -> {
                log.warn("Khoa with ID {} not found for update.", nganhUpdate.getKhoaId());
                return new AppException(HttpStatus.BAD_REQUEST, "Khoa không tồn tại", null);
            });
        }

        // Cập nhật các trường từ DTO và set Khoa mới (nếu có thay đổi)
        nganhMapper.updateNganh(existingNganh, nganhUpdate);
        existingNganh.setKhoa(khoa);

        try {
            Nganh updatedNganh = nganhRepository.save(existingNganh);
            log.info("Successfully updated Nganh with ID: {}", updatedNganh.getId());
            NganhResponse responseDto = nganhMapper.toNganhResponse(updatedNganh);
            return ApiResponse.<NganhResponse>builder().status(HttpStatus.OK.value()).message("Cập nhật ngành thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
        } catch (DataIntegrityViolationException e) {
            log.error("DataIntegrityViolationException while updating Nganh: {}", e.getMessage());
            // Lỗi này ít xảy ra khi update nếu không sửa trường unique
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi cập nhật ngành.", null);
        }
    }

    public ApiResponse<NganhResponse> getNganhById(Integer id) {
        log.info("Fetching Nganh with ID: {}", id);
        Nganh nganh = findByIdHelper(id);
        NganhResponse responseDto = nganhMapper.toNganhResponse(nganh);
        log.info("Successfully fetched Nganh with ID: {}", id);
        return ApiResponse.<NganhResponse>builder().status(HttpStatus.OK.value()).message("Lấy thông tin ngành thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
    }

    @Transactional
    public ApiResponse<String> deleteNganh(Integer id) {
        log.info("Deleting Nganh with ID: {}", id);
        Nganh nganh = findByIdHelper(id); // Check existence
        nganhRepository.delete(nganh);
        log.info("Successfully deleted Nganh with ID: {}", id);
        return ApiResponse.<String>builder().status(HttpStatus.OK.value()).message("Xóa ngành thành công").result(null).timestamp(LocalDateTime.now()).build();
    }

    public PageResponse<NganhResponse> getAllNganh(Pageable pageable) {
        log.info("Fetching Nganh list with pagination: {}", pageable);
        Page<Nganh> nganhPage = nganhRepository.findAll(pageable);
        Page<NganhResponse> responsePage = nganhPage.map(nganhMapper::toNganhResponse);
        log.info("Successfully fetched Nganh list. Total elements: {}, Total pages: {}", responsePage.getTotalElements(), responsePage.getTotalPages());

        return PageResponse.<NganhResponse>builder().content(responsePage.getContent()).totalPages(responsePage.getTotalPages()).totalElements(responsePage.getTotalElements()).size(responsePage.getSize()).number(responsePage.getNumber()).build();
    }

    // Helper method to find Nganh by ID or throw exception
    private Nganh findByIdHelper(Integer id) {
        return nganhRepository.findById(id).orElseThrow(() -> {
            log.warn("Nganh with ID {} not found.", id);
            return new AppException(HttpStatus.BAD_REQUEST, "Không tìm thấy Ngành với id: " + id, null);
        });
    }
}


/* ===== src\main\java\com\hau\websocket\service\NguoiDungService.java ===== */
package com.hau.websocket.service;

import com.hau.websocket.dto.request.NguoiDungCreate;
import com.hau.websocket.dto.request.NguoiDungUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.NguoiDungResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.entity.LopHoc;
import com.hau.websocket.entity.NguoiDung;
import com.hau.websocket.entity.PhongBan;
import com.hau.websocket.exception.AppException;
import com.hau.websocket.mapper.NguoiDungMapper;
import com.hau.websocket.repository.LopHocRepository;
import com.hau.websocket.repository.NguoiDungRepository;
import com.hau.websocket.repository.PhongBanRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.password.PasswordEncoder; // Import PasswordEncoder
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils; // Import StringUtils

import java.time.LocalDateTime;
import java.util.Objects; // Import Objects

@Service
@RequiredArgsConstructor
@Slf4j
public class NguoiDungService {

    private final NguoiDungRepository nguoiDungRepository;
    private final NguoiDungMapper nguoiDungMapper;
    private final PasswordEncoder passwordEncoder; // Inject PasswordEncoder
    private final LopHocRepository lopHocRepository; // Inject LopHocRepository
    private final PhongBanRepository phongBanRepository; // Inject PhongBanRepository

    @Transactional
    public ApiResponse<NguoiDungResponse> createNguoiDung(NguoiDungCreate createDto) {
        log.info("Creating NguoiDung with maDangNhap: {}", createDto.getMaDangNhap());

        // --- Kiểm tra Unique Constraints ---
        checkUniqueness(createDto.getMaDangNhap(), createDto.getEmail(), createDto.getMaSinhVien(), createDto.getMaCanBo(), null);

        NguoiDung nguoiDung = nguoiDungMapper.toNguoiDung(createDto);

        // --- Xử lý mật khẩu ---
        nguoiDung.setMatKhau(passwordEncoder.encode(createDto.getMatKhau()));
        nguoiDung.setTrangThai(true); // Mặc định active khi tạo mới

        // --- Xử lý các trường liên quan ---
        setRelationships(nguoiDung, createDto.getLopHocId(), createDto.getPhongBanId());

        // --- Xử lý trường boolean mặc định ---
        if (createDto.getLaDauMoiLienLac() == null) {
            nguoiDung.setLaDauMoiLienLac(false);
        }

        try {
            NguoiDung savedNguoiDung = nguoiDungRepository.save(nguoiDung);
            log.info("Successfully created NguoiDung with ID: {}", savedNguoiDung.getId());
            NguoiDungResponse responseDto = nguoiDungMapper.toNguoiDungResponse(savedNguoiDung);
            return ApiResponse.<NguoiDungResponse>builder().status(HttpStatus.CREATED.value()).message("Tạo mới người dùng thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
        } catch (DataIntegrityViolationException e) {
            log.error("DataIntegrityViolationException while creating NguoiDung: {}", e.getMessage());
            // Lỗi này có thể xảy ra nếu check uniqueness ở trên bị race condition
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi tạo người dùng, dữ liệu không hợp lệ hoặc bị trùng.", null);
        }
    }

    @Transactional
    public ApiResponse<NguoiDungResponse> updateNguoiDung(Integer id, NguoiDungUpdate updateDto) {
        log.info("Updating NguoiDung with ID: {}", id);
        NguoiDung existingNguoiDung = findByIdHelper(id);

        // --- Kiểm tra Unique Constraints nếu email thay đổi ---
        if (StringUtils.hasText(updateDto.getEmail()) && !updateDto.getEmail().equalsIgnoreCase(existingNguoiDung.getEmail())) {
            checkUniqueness(null, updateDto.getEmail(), null, null, id);
        }

        // --- Cập nhật thông tin ---
        nguoiDungMapper.updateNguoiDung(existingNguoiDung, updateDto);

        // --- Cập nhật các trường liên quan nếu có thay đổi ---
        updateRelationships(existingNguoiDung, updateDto.getLopHocId(), updateDto.getPhongBanId());

        // --- Xử lý trường boolean mặc định ---
        if (updateDto.getLaDauMoiLienLac() == null) {
            existingNguoiDung.setLaDauMoiLienLac(existingNguoiDung.getLaDauMoiLienLac() != null ? existingNguoiDung.getLaDauMoiLienLac() : false);
        } else {
            existingNguoiDung.setLaDauMoiLienLac(updateDto.getLaDauMoiLienLac());
        }


        try {
            NguoiDung updatedNguoiDung = nguoiDungRepository.save(existingNguoiDung);
            log.info("Successfully updated NguoiDung with ID: {}", updatedNguoiDung.getId());
            NguoiDungResponse responseDto = nguoiDungMapper.toNguoiDungResponse(updatedNguoiDung);
            return ApiResponse.<NguoiDungResponse>builder().status(HttpStatus.OK.value()).message("Cập nhật người dùng thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
        } catch (DataIntegrityViolationException e) {
            log.error("DataIntegrityViolationException while updating NguoiDung: {}", e.getMessage());
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi cập nhật người dùng, dữ liệu không hợp lệ hoặc bị trùng.", null);
        }
    }

    public ApiResponse<NguoiDungResponse> getNguoiDungById(Integer id) {
        log.info("Fetching NguoiDung with ID: {}", id);
        NguoiDung nguoiDung = findByIdHelper(id);
        NguoiDungResponse responseDto = nguoiDungMapper.toNguoiDungResponse(nguoiDung);
        log.info("Successfully fetched NguoiDung with ID: {}", id);
        return ApiResponse.<NguoiDungResponse>builder().status(HttpStatus.OK.value()).message("Lấy thông tin người dùng thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
    }

    @Transactional
    public ApiResponse<String> deleteNguoiDung(Integer id) {
        log.info("Deleting NguoiDung with ID: {}", id);
        NguoiDung nguoiDung = findByIdHelper(id); // Check existence
        // Thêm logic kiểm tra ràng buộc trước khi xóa nếu cần (ví dụ: không xóa admin cuối cùng)
        nguoiDungRepository.delete(nguoiDung);
        log.info("Successfully deleted NguoiDung with ID: {}", id);
        return ApiResponse.<String>builder().status(HttpStatus.OK.value()).message("Xóa người dùng thành công").result(null).timestamp(LocalDateTime.now()).build();
    }

    public PageResponse<NguoiDungResponse> getAllNguoiDung(Pageable pageable) {
        log.info("Fetching NguoiDung list with pagination: {}", pageable);
        Page<NguoiDung> nguoiDungPage = nguoiDungRepository.findAll(pageable);
        Page<NguoiDungResponse> responsePage = nguoiDungPage.map(nguoiDungMapper::toNguoiDungResponse);
        log.info("Successfully fetched NguoiDung list. Total elements: {}, Total pages: {}", responsePage.getTotalElements(), responsePage.getTotalPages());

        return PageResponse.<NguoiDungResponse>builder().content(responsePage.getContent()).totalPages(responsePage.getTotalPages()).totalElements(responsePage.getTotalElements()).size(responsePage.getSize()).number(responsePage.getNumber()).build();
    }

    // --- Helper Methods ---

    private NguoiDung findByIdHelper(Integer id) {
        return nguoiDungRepository.findById(id).orElseThrow(() -> {
            log.warn("NguoiDung with ID {} not found.", id);
            return new AppException(HttpStatus.BAD_REQUEST, "Không tìm thấy Người dùng với id: " + id, null);
        });
    }

    private void checkUniqueness(String maDangNhap, String email, String maSinhVien, String maCanBo, Integer currentUserId) {
        if (StringUtils.hasText(maDangNhap)) {
            nguoiDungRepository.findByMaDangNhap(maDangNhap).filter(user -> !Objects.equals(user.getId(), currentUserId)) // Bỏ qua chính user hiện tại khi update
                    .ifPresent(existing -> {
                        throw new AppException(HttpStatus.BAD_REQUEST, "Mã đăng nhập đã tồn tại", null);
                    });
        }
        if (StringUtils.hasText(email)) {
            nguoiDungRepository.findByEmail(email).filter(user -> !Objects.equals(user.getId(), currentUserId)).ifPresent(existing -> {
                throw new AppException(HttpStatus.BAD_REQUEST, "Email đã tồn tại", null);
            });
        }
        if (StringUtils.hasText(maSinhVien)) {
            nguoiDungRepository.findByMaSinhVien(maSinhVien).filter(user -> !Objects.equals(user.getId(), currentUserId)).ifPresent(existing -> {
                throw new AppException(HttpStatus.BAD_REQUEST, "Mã sinh viên đã tồn tại", null);
            });
        }
        if (StringUtils.hasText(maCanBo)) {
            nguoiDungRepository.findByMaCanBo(maCanBo).filter(user -> !Objects.equals(user.getId(), currentUserId)).ifPresent(existing -> {
                throw new AppException(HttpStatus.BAD_REQUEST, "Mã cán bộ đã tồn tại", null);
            });
        }
    }

    private void setRelationships(NguoiDung nguoiDung, Integer lopHocId, Integer phongBanId) {
        if (lopHocId != null) {
            LopHoc lopHoc = lopHocRepository.findById(lopHocId).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Lớp học không tồn tại", null));
            nguoiDung.setLopHoc(lopHoc);
        } else {
            nguoiDung.setLopHoc(null);
        }

        if (phongBanId != null) {
            PhongBan phongBan = phongBanRepository.findById(phongBanId).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Phòng ban không tồn tại", null));
            nguoiDung.setPhongBan(phongBan);
        } else {
            nguoiDung.setPhongBan(null);
        }
    }

    private void updateRelationships(NguoiDung nguoiDung, Integer newLopHocId, Integer newPhongBanId) {
        // Cập nhật Lớp học
        if (newLopHocId == null) {
            nguoiDung.setLopHoc(null);
        } else if (nguoiDung.getLopHoc() == null || !Objects.equals(nguoiDung.getLopHoc().getId(), newLopHocId)) {
            LopHoc lopHoc = lopHocRepository.findById(newLopHocId).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Lớp học không tồn tại", null));
            nguoiDung.setLopHoc(lopHoc);
        }
        // Nếu newLopHocId bằng ID hiện tại thì không cần làm gì

        // Cập nhật Phòng ban
        if (newPhongBanId == null) {
            nguoiDung.setPhongBan(null);
        } else if (nguoiDung.getPhongBan() == null || !Objects.equals(nguoiDung.getPhongBan().getId(), newPhongBanId)) {
            PhongBan phongBan = phongBanRepository.findById(newPhongBanId).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Phòng ban không tồn tại", null));
            nguoiDung.setPhongBan(phongBan);
        }
        // Nếu newPhongBanId bằng ID hiện tại thì không cần làm gì
    }
}


/* ===== src\main\java\com\hau\websocket\service\NhomService.java ===== */
package com.hau.websocket.service;

import com.hau.websocket.dto.request.NhomCreate;
import com.hau.websocket.dto.request.NhomUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.NhomResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.entity.Nhom;
import com.hau.websocket.entity.NguoiDung;
import com.hau.websocket.exception.AppException;
import com.hau.websocket.mapper.NhomMapper;
import com.hau.websocket.repository.NguoiDungRepository;
import com.hau.websocket.repository.NhomRepository;
// Import repository Nhom_ThanhVien nếu cần xóa thành viên khi xóa nhóm
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
@Slf4j
public class NhomService {

    private final NhomRepository nhomRepository;
    private final NhomMapper nhomMapper;
    private final NguoiDungRepository nguoiDungRepository;
    // private final NhomThanhVienRepository nhomThanhVienRepository; // Inject nếu cần

    @Transactional
    public ApiResponse<NhomResponse> createNhom(NhomCreate createDto) {
        log.info("Creating Nhom with name: {}", createDto.getTenNhom());

        // Tìm người tạo
        NguoiDung nguoiTao = nguoiDungRepository.findById(createDto.getNguoiTaoId()).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Người tạo không tồn tại", null));

        Nhom nhom = nhomMapper.toNhom(createDto);
        nhom.setNguoiTao(nguoiTao);

        // Set default loại nhóm nếu không được cung cấp
        if (!StringUtils.hasText(createDto.getLoaiNhom())) {
            nhom.setLoaiNhom("TuyChinh");
        } else {
            nhom.setLoaiNhom(createDto.getLoaiNhom());
        }

        // TODO: Thêm logic kiểm tra tên nhóm có bị trùng trong phạm vi nào đó không (ví dụ: do cùng người tạo?)

        Nhom savedNhom = nhomRepository.save(nhom);

        // TODO: Tự động thêm người tạo làm thành viên đầu tiên và quản trị viên của nhóm (trong Nhom_ThanhVien)

        log.info("Successfully created Nhom with ID: {}", savedNhom.getId());
        NhomResponse responseDto = nhomMapper.toNhomResponse(savedNhom);

        return ApiResponse.<NhomResponse>builder().status(HttpStatus.CREATED.value()).message("Tạo mới nhóm thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
    }

    @Transactional
    public ApiResponse<NhomResponse> updateNhom(Integer id, NhomUpdate updateDto, Integer currentUserId) {
        log.info("Updating Nhom with ID: {}", id);
        Nhom existingNhom = findByIdHelper(id);

        // --- Kiểm tra quyền cập nhật ---
        // Chỉ người tạo nhóm hoặc Admin mới có quyền sửa (Cần logic lấy currentUserId từ Security Context)
        // if (!existingNhom.getNguoiTao().getId().equals(currentUserId) /* && !currentUserIsAdmin() */ ) {
        //     throw new AppException(HttpStatus.FORBIDDEN, "Bạn không có quyền cập nhật nhóm này", null);
        // }

        nhomMapper.updateNhom(existingNhom, updateDto);

        Nhom updatedNhom = nhomRepository.save(existingNhom);
        log.info("Successfully updated Nhom with ID: {}", updatedNhom.getId());
        NhomResponse responseDto = nhomMapper.toNhomResponse(updatedNhom);

        return ApiResponse.<NhomResponse>builder().status(HttpStatus.OK.value()).message("Cập nhật nhóm thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
    }

    public ApiResponse<NhomResponse> getNhomById(Integer id) {
        log.info("Fetching Nhom with ID: {}", id);
        Nhom nhom = findByIdHelper(id);
        // TODO: Kiểm tra xem người dùng hiện tại có phải là thành viên nhóm không trước khi trả về?
        NhomResponse responseDto = nhomMapper.toNhomResponse(nhom);
        log.info("Successfully fetched Nhom with ID: {}", id);
        return ApiResponse.<NhomResponse>builder().status(HttpStatus.OK.value()).message("Lấy thông tin nhóm thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
    }

    @Transactional
    public ApiResponse<String> deleteNhom(Integer id, Integer currentUserId) {
        log.info("Deleting Nhom with ID: {}", id);
        Nhom nhom = findByIdHelper(id);

        // --- Kiểm tra quyền xóa ---
        // Chỉ người tạo nhóm hoặc Admin mới có quyền xóa
        // if (!nhom.getNguoiTao().getId().equals(currentUserId) /* && !currentUserIsAdmin() */) {
        //     throw new AppException(HttpStatus.FORBIDDEN, "Bạn không có quyền xóa nhóm này", null);
        // }

        // --- Xóa các bản ghi liên quan trước (ví dụ: thành viên, tin nhắn) ---
        // nhomThanhVienRepository.deleteByNhomId(id);
        // tinNhanTrongNhomRepository.deleteByNhomId(id); // Nếu có

        nhomRepository.delete(nhom);
        log.info("Successfully deleted Nhom with ID: {}", id);
        return ApiResponse.<String>builder().status(HttpStatus.OK.value()).message("Xóa nhóm thành công").result(null).timestamp(LocalDateTime.now()).build();
    }

    public PageResponse<NhomResponse> getAllNhom(Pageable pageable) {
        log.info("Fetching Nhom list with pagination: {}", pageable);
        // TODO: Có thể chỉ nên trả về các nhóm mà người dùng hiện tại là thành viên?
        Page<Nhom> nhomPage = nhomRepository.findAll(pageable);
        Page<NhomResponse> responsePage = nhomPage.map(nhomMapper::toNhomResponse);
        log.info("Successfully fetched Nhom list. Total elements: {}, Total pages: {}", responsePage.getTotalElements(), responsePage.getTotalPages());

        return PageResponse.<NhomResponse>builder().content(responsePage.getContent()).totalPages(responsePage.getTotalPages()).totalElements(responsePage.getTotalElements()).size(responsePage.getSize()).number(responsePage.getNumber()).build();
    }

    // Helper method
    private Nhom findByIdHelper(Integer id) {
        return nhomRepository.findById(id).orElseThrow(() -> {
            log.warn("Nhom with ID {} not found.", id);
            return new AppException(HttpStatus.BAD_REQUEST, "Không tìm thấy Nhóm với id: " + id, null);
        });
    }
}


/* ===== src\main\java\com\hau\websocket\service\NhomThanhVienService.java ===== */
package com.hau.websocket.service;

import com.hau.websocket.dto.request.NhomThanhVienAddRequest;
import com.hau.websocket.dto.request.NhomThanhVienUpdateRequest;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.NhomThamGiaResponse;
import com.hau.websocket.dto.response.NhomThanhVienResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.entity.*; // Import Nhom, NguoiDung, NhomThanhVien, NhomThanhVienId
import com.hau.websocket.exception.AppException;
import com.hau.websocket.mapper.NhomThanhVienMapper;
import com.hau.websocket.repository.NguoiDungRepository;
import com.hau.websocket.repository.NhomRepository;
import com.hau.websocket.repository.NhomThanhVienRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Slf4j
public class NhomThanhVienService {

    private final NhomThanhVienRepository nhomThanhVienRepository;
    private final NhomRepository nhomRepository;
    private final NguoiDungRepository nguoiDungRepository;
    private final NhomThanhVienMapper nhomThanhVienMapper;

    @Transactional
    public ApiResponse<NhomThanhVienResponse> addThanhVien(Integer nhomId, NhomThanhVienAddRequest addRequest, Integer currentUserId) {
        log.info("Adding user ID {} to group ID {}", addRequest.getNguoiDungId(), nhomId);

        Nhom nhom = findNhomByIdHelper(nhomId);
        NguoiDung nguoiDung = findNguoiDungByIdHelper(addRequest.getNguoiDungId());

        // --- Kiểm tra quyền thêm thành viên (ví dụ: chỉ admin nhóm) ---
        checkAdminQuyen(nhomId, currentUserId, "thêm thành viên");

        // Kiểm tra thành viên đã tồn tại chưa
        NhomThanhVienId id = new NhomThanhVienId(nhomId, addRequest.getNguoiDungId());
        if (nhomThanhVienRepository.existsById(id)) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Người dùng đã là thành viên của nhóm", null);
        }

        // Tạo bản ghi NhomThanhVien
        NhomThanhVien thanhVien = new NhomThanhVien();
        thanhVien.setId(id);
        thanhVien.setNhom(nhom);
        thanhVien.setNguoiDung(nguoiDung);
        thanhVien.setVaiTroTrongNhom(StringUtils.hasText(addRequest.getVaiTroTrongNhom()) ? addRequest.getVaiTroTrongNhom() : "ThanhVien");
        // ngayThamGia sẽ được set tự động

        NhomThanhVien savedThanhVien = nhomThanhVienRepository.save(thanhVien);
        log.info("Successfully added user ID {} to group ID {}", addRequest.getNguoiDungId(), nhomId);

        return ApiResponse.<NhomThanhVienResponse>builder().status(HttpStatus.CREATED.value()).message("Thêm thành viên vào nhóm thành công").result(nhomThanhVienMapper.toNhomThanhVienResponse(savedThanhVien)).timestamp(LocalDateTime.now()).build();
    }

    @Transactional
    public ApiResponse<NhomThanhVienResponse> updateVaiTro(Integer nhomId, Integer nguoiDungId, NhomThanhVienUpdateRequest updateRequest, Integer currentUserId) {
        log.info("Updating role for user ID {} in group ID {}", nguoiDungId, nhomId);

        // --- Kiểm tra quyền cập nhật vai trò (ví dụ: chỉ admin nhóm) ---
        checkAdminQuyen(nhomId, currentUserId, "cập nhật vai trò thành viên");

        NhomThanhVien thanhVien = findThanhVienByIdHelper(nhomId, nguoiDungId);

        // Không cho phép thay đổi vai trò của người tạo nhóm? (Tùy logic)
        // if (thanhVien.getNguoiDung().getId().equals(thanhVien.getNhom().getNguoiTao().getId())) {
        //     throw new AppException(HttpStatus.BAD_REQUEST, "Không thể thay đổi vai trò của người tạo nhóm", null);
        // }

        thanhVien.setVaiTroTrongNhom(updateRequest.getVaiTroTrongNhom());
        NhomThanhVien updatedThanhVien = nhomThanhVienRepository.save(thanhVien);
        log.info("Successfully updated role for user ID {} in group ID {}", nguoiDungId, nhomId);

        return ApiResponse.<NhomThanhVienResponse>builder().status(HttpStatus.OK.value()).message("Cập nhật vai trò thành viên thành công").result(nhomThanhVienMapper.toNhomThanhVienResponse(updatedThanhVien)).timestamp(LocalDateTime.now()).build();
    }


    @Transactional
    public ApiResponse<String> removeThanhVien(Integer nhomId, Integer nguoiDungId, Integer currentUserId) {
        log.info("Removing user ID {} from group ID {}", nguoiDungId, nhomId);

        NhomThanhVien thanhVien = findThanhVienByIdHelper(nhomId, nguoiDungId);

        // --- Kiểm tra quyền xóa thành viên (ví dụ: admin nhóm hoặc chính người đó rời nhóm) ---
        boolean isAdmin = isAdminNhom(nhomId, currentUserId);
        boolean isSelf = currentUserId.equals(nguoiDungId);

        if (!isAdmin && !isSelf) {
            throw new AppException(HttpStatus.FORBIDDEN, "Bạn không có quyền xóa thành viên này", null);
        }

        // Kiểm tra không cho phép xóa người tạo nhóm?
        if (thanhVien.getNguoiDung().getId().equals(thanhVien.getNhom().getNguoiTao().getId())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Không thể xóa người tạo nhóm khỏi nhóm", null);
        }

        nhomThanhVienRepository.delete(thanhVien);
        log.info("Successfully removed user ID {} from group ID {}", nguoiDungId, nhomId);

        return ApiResponse.<String>builder().status(HttpStatus.OK.value()).message("Xóa thành viên khỏi nhóm thành công").result(null).timestamp(LocalDateTime.now()).build();
    }

    public PageResponse<NhomThanhVienResponse> getThanhVienByNhom(Integer nhomId, Pageable pageable, Integer currentUserId) {
        log.info("Fetching members for group ID {} with pagination: {}", nhomId, pageable);

        // --- Kiểm tra quyền xem thành viên (ví dụ: chỉ thành viên nhóm mới được xem) ---
        // findThanhVienByIdHelper(nhomId, currentUserId); // Cách đơn giản để check là thành viên

        Page<NhomThanhVien> thanhVienPage = nhomThanhVienRepository.findById_NhomId(nhomId, pageable);
        Page<NhomThanhVienResponse> responsePage = thanhVienPage.map(nhomThanhVienMapper::toNhomThanhVienResponse);
        log.info("Successfully fetched members for group ID {}. Total elements: {}, Total pages: {}", nhomId, responsePage.getTotalElements(), responsePage.getTotalPages());

        return PageResponse.<NhomThanhVienResponse>builder().content(responsePage.getContent()).totalPages(responsePage.getTotalPages()).totalElements(responsePage.getTotalElements()).size(responsePage.getSize()).number(responsePage.getNumber()).build();
    }

    public PageResponse<NhomThamGiaResponse> getNhomByNguoiDung(Integer nguoiDungId, Pageable pageable) {
        log.info("Fetching groups for user ID {} with pagination: {}", nguoiDungId, pageable);

        Page<NhomThanhVien> thanhVienPage = nhomThanhVienRepository.findById_NguoiDungId(nguoiDungId, pageable);
        Page<NhomThamGiaResponse> responsePage = thanhVienPage.map(nhomThanhVienMapper::toNhomThamGiaResponse);
        log.info("Successfully fetched groups for user ID {}. Total elements: {}, Total pages: {}", nguoiDungId, responsePage.getTotalElements(), responsePage.getTotalPages());

        return PageResponse.<NhomThamGiaResponse>builder().content(responsePage.getContent()).totalPages(responsePage.getTotalPages()).totalElements(responsePage.getTotalElements()).size(responsePage.getSize()).number(responsePage.getNumber()).build();
    }


    // --- Helper Methods ---

    private Nhom findNhomByIdHelper(Integer nhomId) {
        return nhomRepository.findById(nhomId).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Nhóm không tồn tại", null));
    }

    private NguoiDung findNguoiDungByIdHelper(Integer nguoiDungId) {
        return nguoiDungRepository.findById(nguoiDungId).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Người dùng không tồn tại", null));
    }

    private NhomThanhVien findThanhVienByIdHelper(Integer nhomId, Integer nguoiDungId) {
        return nhomThanhVienRepository.findById_NhomIdAndId_NguoiDungId(nhomId, nguoiDungId).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Người dùng không phải là thành viên của nhóm này", null));
    }

    // Placeholder - Cần logic kiểm tra vai trò thực tế
    private boolean isAdminNhom(Integer nhomId, Integer userId) {
        if (userId == null) return false;
        Optional<NhomThanhVien> tvOpt = nhomThanhVienRepository.findById_NhomIdAndId_NguoiDungId(nhomId, userId);
        return tvOpt.map(tv -> "QuanTriVien".equalsIgnoreCase(tv.getVaiTroTrongNhom())).orElse(false);
    }

    // Placeholder - Kiểm tra quyền admin nhóm
    private void checkAdminQuyen(Integer nhomId, Integer userId, String action) {
        if (!isAdminNhom(nhomId, userId)) {
            throw new AppException(HttpStatus.FORBIDDEN, "Bạn không có quyền " + action + " trong nhóm này", null);
        }
    }
}


/* ===== src\main\java\com\hau\websocket\service\PhongBanService.java ===== */
package com.hau.websocket.service;

import com.hau.websocket.dto.request.PhongBanCreate;
import com.hau.websocket.dto.request.PhongBanUpdate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.PhongBanResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.entity.PhongBan;
import com.hau.websocket.exception.AppException;
import com.hau.websocket.mapper.PhongBanMapper;
import com.hau.websocket.repository.PhongBanRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
@Slf4j
public class PhongBanService {

    private final PhongBanRepository phongBanRepository;
    private final PhongBanMapper phongBanMapper;

    @Transactional
    public ApiResponse<PhongBanResponse> createPhongBan(PhongBanCreate createDto) {
        log.info("Creating PhongBan with code: {}", createDto.getMaPhongBan());

        phongBanRepository.findByMaPhongBan(createDto.getMaPhongBan()).ifPresent(existing -> {
            log.warn("Ma phong ban '{}' already exists.", createDto.getMaPhongBan());
            throw new AppException(HttpStatus.BAD_REQUEST, "Mã phòng ban đã tồn tại", null);
        });

        PhongBan phongBan = phongBanMapper.toPhongBan(createDto);

        try {
            PhongBan savedPhongBan = phongBanRepository.save(phongBan);
            log.info("Successfully created PhongBan with ID: {}", savedPhongBan.getId());
            PhongBanResponse responseDto = phongBanMapper.toPhongBanResponse(savedPhongBan);
            return ApiResponse.<PhongBanResponse>builder().status(HttpStatus.CREATED.value()).message("Tạo mới phòng ban thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
        } catch (DataIntegrityViolationException e) {
            log.error("DataIntegrityViolationException while creating PhongBan: {}", e.getMessage());
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi tạo phòng ban, có thể do trùng mã.", null);
        }
    }

    @Transactional
    public ApiResponse<PhongBanResponse> updatePhongBan(Integer id, PhongBanUpdate updateDto) {
        log.info("Updating PhongBan with ID: {}", id);
        PhongBan existingPhongBan = findByIdHelper(id);

        phongBanMapper.updatePhongBan(existingPhongBan, updateDto);

        try {
            PhongBan updatedPhongBan = phongBanRepository.save(existingPhongBan);
            log.info("Successfully updated PhongBan with ID: {}", updatedPhongBan.getId());
            PhongBanResponse responseDto = phongBanMapper.toPhongBanResponse(updatedPhongBan);
            return ApiResponse.<PhongBanResponse>builder().status(HttpStatus.OK.value()).message("Cập nhật phòng ban thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
        } catch (DataIntegrityViolationException e) {
            log.error("DataIntegrityViolationException while updating PhongBan: {}", e.getMessage());
            // Lỗi này ít xảy ra khi update nếu không sửa trường unique
            throw new AppException(HttpStatus.BAD_REQUEST, "Lỗi cập nhật phòng ban.", null);
        }
    }

    public ApiResponse<PhongBanResponse> getPhongBanById(Integer id) {
        log.info("Fetching PhongBan with ID: {}", id);
        PhongBan phongBan = findByIdHelper(id);
        PhongBanResponse responseDto = phongBanMapper.toPhongBanResponse(phongBan);
        log.info("Successfully fetched PhongBan with ID: {}", id);
        return ApiResponse.<PhongBanResponse>builder().status(HttpStatus.OK.value()).message("Lấy thông tin phòng ban thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
    }

    @Transactional
    public ApiResponse<String> deletePhongBan(Integer id) {
        log.info("Deleting PhongBan with ID: {}", id);
        PhongBan phongBan = findByIdHelper(id); // Check existence
        // Cần thêm logic kiểm tra xem phòng ban có đang được sử dụng (ví dụ: bởi NguoiDung) hay không trước khi xóa
        // if (nguoiDungRepository.existsByPhongBanId(id)) {
        //     throw new AppException(HttpStatus.BAD_REQUEST, "Không thể xóa phòng ban đang được sử dụng.", null);
        // }
        phongBanRepository.delete(phongBan);
        log.info("Successfully deleted PhongBan with ID: {}", id);
        return ApiResponse.<String>builder().status(HttpStatus.OK.value()).message("Xóa phòng ban thành công").result(null).timestamp(LocalDateTime.now()).build();
    }

    public PageResponse<PhongBanResponse> getAllPhongBan(Pageable pageable) {
        log.info("Fetching PhongBan list with pagination: {}", pageable);
        Page<PhongBan> phongBanPage = phongBanRepository.findAll(pageable);
        Page<PhongBanResponse> responsePage = phongBanPage.map(phongBanMapper::toPhongBanResponse);
        log.info("Successfully fetched PhongBan list. Total elements: {}, Total pages: {}", responsePage.getTotalElements(), responsePage.getTotalPages());

        return PageResponse.<PhongBanResponse>builder().content(responsePage.getContent()).totalPages(responsePage.getTotalPages()).totalElements(responsePage.getTotalElements()).size(responsePage.getSize()).number(responsePage.getNumber()).build();
    }

    // Helper method
    private PhongBan findByIdHelper(Integer id) {
        return phongBanRepository.findById(id).orElseThrow(() -> {
            log.warn("PhongBan with ID {} not found.", id);
            return new AppException(HttpStatus.BAD_REQUEST, "Không tìm thấy Phòng ban với id: " + id, null);
        });
    }
}


/* ===== src\main\java\com\hau\websocket\service\TinNhanService.java ===== */
package com.hau.websocket.service;

import com.hau.websocket.dto.request.TinNhanCreate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.TinNhanResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.entity.NguoiDung;
import com.hau.websocket.entity.TinNhan;
import com.hau.websocket.exception.AppException;
import com.hau.websocket.mapper.TinNhanMapper;
import com.hau.websocket.repository.NguoiDungRepository;
import com.hau.websocket.repository.TinNhanRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
@Slf4j
public class TinNhanService {

    private final TinNhanRepository tinNhanRepository;
    private final TinNhanMapper tinNhanMapper;
    private final NguoiDungRepository nguoiDungRepository;

    @Transactional
    public ApiResponse<TinNhanResponse> createTinNhan(TinNhanCreate createDto) {
        log.info("Creating TinNhan for conversation ID: {}", createDto.getCuocTroChuyenId());

        // Validate: Phải có nội dung hoặc tệp đính kèm
        if (!StringUtils.hasText(createDto.getNoiDung()) && !StringUtils.hasText(createDto.getDinhKemUrl())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Tin nhắn phải có nội dung hoặc tệp đính kèm.", null);
        }

        // Tìm người gửi và người nhận
        NguoiDung nguoiGui = nguoiDungRepository.findById(createDto.getNguoiGuiId()).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Người gửi không tồn tại", null));
        NguoiDung nguoiNhan = nguoiDungRepository.findById(createDto.getNguoiNhanId()).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Người nhận không tồn tại", null));

        // TODO: Thêm logic kiểm tra xem người gửi có quyền gửi tin nhắn cho người nhận không (nếu cần)

        TinNhan tinNhan = tinNhanMapper.toTinNhan(createDto);
        tinNhan.setNguoiGui(nguoiGui);
        tinNhan.setNguoiNhan(nguoiNhan);
        // thoiGianGui sẽ được set tự động bởi @CreationTimestamp

        TinNhan savedTinNhan = tinNhanRepository.save(tinNhan);
        log.info("Successfully created TinNhan with ID: {}", savedTinNhan.getId());
        TinNhanResponse responseDto = tinNhanMapper.toTinNhanResponse(savedTinNhan);

        return ApiResponse.<TinNhanResponse>builder().status(HttpStatus.CREATED.value()).message("Gửi tin nhắn thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
    }

    // Lấy tin nhắn theo ID (ít dùng)
    public ApiResponse<TinNhanResponse> getTinNhanById(Integer id) {
        log.info("Fetching TinNhan with ID: {}", id);
        TinNhan tinNhan = findByIdHelper(id);
        TinNhanResponse responseDto = tinNhanMapper.toTinNhanResponse(tinNhan);
        log.info("Successfully fetched TinNhan with ID: {}", id);
        return ApiResponse.<TinNhanResponse>builder().status(HttpStatus.OK.value()).message("Lấy thông tin tin nhắn thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
    }

    @Transactional
    public ApiResponse<String> deleteTinNhan(Integer id) {
        log.info("Deleting TinNhan with ID: {}", id);
        TinNhan tinNhan = findByIdHelper(id);
        // TODO: Thêm logic kiểm tra quyền xóa tin nhắn (ví dụ: chỉ người gửi được xóa?)
        tinNhanRepository.delete(tinNhan);
        log.info("Successfully deleted TinNhan with ID: {}", id);
        return ApiResponse.<String>builder().status(HttpStatus.OK.value()).message("Xóa tin nhắn thành công").result(null).timestamp(LocalDateTime.now()).build();
    }

    // Lấy danh sách tin nhắn theo cuộc trò chuyện (phân trang)
    public PageResponse<TinNhanResponse> getTinNhanByCuocTroChuyenId(String cuocTroChuyenId, Pageable pageable) {
        log.info("Fetching TinNhan list for conversation ID: {} with pagination: {}", cuocTroChuyenId, pageable);
        Page<TinNhan> tinNhanPage = tinNhanRepository.findByCuocTroChuyenIdOrderByThoiGianGuiDesc(cuocTroChuyenId, pageable);
        Page<TinNhanResponse> responsePage = tinNhanPage.map(tinNhanMapper::toTinNhanResponse);
        log.info("Successfully fetched TinNhan list for conversation ID: {}. Total elements: {}, Total pages: {}", cuocTroChuyenId, responsePage.getTotalElements(), responsePage.getTotalPages());

        return PageResponse.<TinNhanResponse>builder().content(responsePage.getContent()).totalPages(responsePage.getTotalPages()).totalElements(responsePage.getTotalElements()).size(responsePage.getSize()).number(responsePage.getNumber()).build();
    }

    // Helper method
    private TinNhan findByIdHelper(Integer id) {
        return tinNhanRepository.findById(id).orElseThrow(() -> {
            log.warn("TinNhan with ID {} not found.", id);
            return new AppException(HttpStatus.BAD_REQUEST, "Không tìm thấy Tin nhắn với id: " + id, null);
        });
    }
}


/* ===== src\main\java\com\hau\websocket\service\TinNhanTrongNhomService.java ===== */
package com.hau.websocket.service;

import com.hau.websocket.dto.request.TinNhanTrongNhomCreate;
import com.hau.websocket.dto.response.ApiResponse;
import com.hau.websocket.dto.response.TinNhanTrongNhomResponse;
import com.hau.websocket.dto.response.PageResponse;
import com.hau.websocket.entity.*; // Import các entity cần thiết
import com.hau.websocket.exception.AppException;
import com.hau.websocket.mapper.TinNhanTrongNhomMapper;
import com.hau.websocket.repository.*; // Import các repository cần thiết
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.Objects;

@Service
@RequiredArgsConstructor
@Slf4j
public class TinNhanTrongNhomService {

    private final TinNhanTrongNhomRepository tinNhanTrongNhomRepository;
    private final TinNhanTrongNhomMapper tinNhanTrongNhomMapper;
    private final NguoiDungRepository nguoiDungRepository;
    private final NhomRepository nhomRepository;
    private final LopHocRepository lopHocRepository;
    private final NhomThanhVienRepository nhomThanhVienRepository; // Để kiểm tra thành viên nhóm

    @Transactional
    public ApiResponse<TinNhanTrongNhomResponse> createTinNhanTrongNhom(TinNhanTrongNhomCreate createDto, Integer currentUserId) {
        log.info("Creating TinNhanTrongNhom by user ID: {}", createDto.getNguoiGuiId());

        // Validate Input
        if (!((createDto.getNhomId() == null) ^ (createDto.getLopHocId() == null))) { // XOR check
            throw new AppException(HttpStatus.BAD_REQUEST, "Tin nhắn phải thuộc về một Nhóm hoặc một Lớp học (không phải cả hai hoặc không).", null);
        }
        if (!StringUtils.hasText(createDto.getNoiDung()) && !StringUtils.hasText(createDto.getDinhKemUrl())) {
            throw new AppException(HttpStatus.BAD_REQUEST, "Tin nhắn phải có nội dung hoặc tệp đính kèm.", null);
        }
        if (!Objects.equals(currentUserId, createDto.getNguoiGuiId())) {
            throw new AppException(HttpStatus.FORBIDDEN, "ID người gửi không khớp với người dùng hiện tại.", null);
        }

        NguoiDung nguoiGui = findNguoiDungByIdHelper(createDto.getNguoiGuiId());
        TinNhanTrongNhom tinNhan = tinNhanTrongNhomMapper.toTinNhanTrongNhom(createDto);
        tinNhan.setNguoiGui(nguoiGui);

        // Xử lý theo loại nhóm (Nhóm tùy chỉnh hoặc Lớp học)
        if (createDto.getNhomId() != null) {
            Nhom nhom = findNhomByIdHelper(createDto.getNhomId());
            // Kiểm tra người gửi có phải thành viên nhóm không
            checkThanhVienNhom(createDto.getNhomId(), createDto.getNguoiGuiId());
            tinNhan.setNhom(nhom);
            log.info("Message belongs to custom group ID: {}", createDto.getNhomId());
        } else { // lopHocId != null
            LopHoc lopHoc = findLopHocByIdHelper(createDto.getLopHocId());
            // Kiểm tra người gửi có thuộc lớp học không
            checkThanhVienLop(lopHoc.getId(), nguoiGui);
            tinNhan.setLopHoc(lopHoc);
            log.info("Message belongs to class group ID: {}", createDto.getLopHocId());
        }

        TinNhanTrongNhom savedTinNhan = tinNhanTrongNhomRepository.save(tinNhan);
        log.info("Successfully created TinNhanTrongNhom with ID: {}", savedTinNhan.getId());
        TinNhanTrongNhomResponse responseDto = tinNhanTrongNhomMapper.toTinNhanTrongNhomResponse(savedTinNhan);

        // TODO: Gửi sự kiện WebSocket tới các thành viên khác trong nhóm/lớp

        return ApiResponse.<TinNhanTrongNhomResponse>builder().status(HttpStatus.CREATED.value()).message("Gửi tin nhắn nhóm thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
    }

    public ApiResponse<TinNhanTrongNhomResponse> getTinNhanTrongNhomById(Integer id, Integer currentUserId) {
        log.info("Fetching TinNhanTrongNhom with ID: {}", id);
        TinNhanTrongNhom tinNhan = findByIdHelper(id);

        // Kiểm tra quyền xem (phải là thành viên của nhóm/lớp chứa tin nhắn)
        if (tinNhan.getNhom() != null) {
            checkThanhVienNhom(tinNhan.getNhom().getId(), currentUserId);
        } else if (tinNhan.getLopHoc() != null) {
            checkThanhVienLop(tinNhan.getLopHoc().getId(), findNguoiDungByIdHelper(currentUserId));
        } else {
            throw new AppException(HttpStatus.INTERNAL_SERVER_ERROR, "Tin nhắn không thuộc nhóm hay lớp học nào.", null); // Lỗi dữ liệu
        }

        TinNhanTrongNhomResponse responseDto = tinNhanTrongNhomMapper.toTinNhanTrongNhomResponse(tinNhan);
        log.info("Successfully fetched TinNhanTrongNhom with ID: {}", id);
        return ApiResponse.<TinNhanTrongNhomResponse>builder().status(HttpStatus.OK.value()).message("Lấy thông tin tin nhắn nhóm thành công").result(responseDto).timestamp(LocalDateTime.now()).build();
    }

    @Transactional
    public ApiResponse<String> deleteTinNhanTrongNhom(Integer id, Integer currentUserId) {
        log.info("Deleting TinNhanTrongNhom with ID: {}", id);
        TinNhanTrongNhom tinNhan = findByIdHelper(id);

        // Kiểm tra quyền xóa (ví dụ: người gửi hoặc admin nhóm/lớp trưởng)
        boolean allowedToDelete = false;
        if (tinNhan.getNguoiGui().getId().equals(currentUserId)) {
            allowedToDelete = true;
        } else if (tinNhan.getNhom() != null) {
            // Check if current user is admin of the custom group
            allowedToDelete = isAdminNhom(tinNhan.getNhom().getId(), currentUserId);
        } else if (tinNhan.getLopHoc() != null) {
            // Check if current user is monitor of the class group
            allowedToDelete = isCanBoLop(currentUserId, tinNhan.getLopHoc().getId());
        }

        if (!allowedToDelete) {
            throw new AppException(HttpStatus.FORBIDDEN, "Bạn không có quyền xóa tin nhắn này", null);
        }

        tinNhanTrongNhomRepository.delete(tinNhan);
        log.info("Successfully deleted TinNhanTrongNhom with ID: {}", id);
        return ApiResponse.<String>builder().status(HttpStatus.OK.value()).message("Xóa tin nhắn nhóm thành công").result(null).timestamp(LocalDateTime.now()).build();
    }


    public PageResponse<TinNhanTrongNhomResponse> getTinNhanByNhomId(Integer nhomId, Pageable pageable, Integer currentUserId) {
        log.info("Fetching messages for custom group ID {} with pagination: {}", nhomId, pageable);
        // Kiểm tra người dùng hiện tại có phải thành viên nhóm không
        checkThanhVienNhom(nhomId, currentUserId);

        Page<TinNhanTrongNhom> tinNhanPage = tinNhanTrongNhomRepository.findByNhomIdOrderByThoiGianGuiDesc(nhomId, pageable);
        Page<TinNhanTrongNhomResponse> responsePage = tinNhanPage.map(tinNhanTrongNhomMapper::toTinNhanTrongNhomResponse);
        log.info("Successfully fetched messages for custom group ID {}. Total elements: {}, Total pages: {}", nhomId, responsePage.getTotalElements(), responsePage.getTotalPages());

        return PageResponse.<TinNhanTrongNhomResponse>builder().content(responsePage.getContent()).totalPages(responsePage.getTotalPages()).totalElements(responsePage.getTotalElements()).size(responsePage.getSize()).number(responsePage.getNumber()).build();
    }

    public PageResponse<TinNhanTrongNhomResponse> getTinNhanByLopHocId(Integer lopHocId, Pageable pageable, Integer currentUserId) {
        log.info("Fetching messages for class group ID {} with pagination: {}", lopHocId, pageable);
        // Kiểm tra người dùng hiện tại có thuộc lớp học không
        NguoiDung currentUser = findNguoiDungByIdHelper(currentUserId);
        checkThanhVienLop(lopHocId, currentUser);

        Page<TinNhanTrongNhom> tinNhanPage = tinNhanTrongNhomRepository.findByLopHocIdOrderByThoiGianGuiDesc(lopHocId, pageable);
        Page<TinNhanTrongNhomResponse> responsePage = tinNhanPage.map(tinNhanTrongNhomMapper::toTinNhanTrongNhomResponse);
        log.info("Successfully fetched messages for class group ID {}. Total elements: {}, Total pages: {}", lopHocId, responsePage.getTotalElements(), responsePage.getTotalPages());

        return PageResponse.<TinNhanTrongNhomResponse>builder().content(responsePage.getContent()).totalPages(responsePage.getTotalPages()).totalElements(responsePage.getTotalElements()).size(responsePage.getSize()).number(responsePage.getNumber()).build();
    }


    // --- Helper Methods ---

    private TinNhanTrongNhom findByIdHelper(Integer id) {
        return tinNhanTrongNhomRepository.findById(id).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Không tìm thấy Tin nhắn nhóm với id: " + id, null));
    }

    private NguoiDung findNguoiDungByIdHelper(Integer nguoiDungId) {
        return nguoiDungRepository.findById(nguoiDungId).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Người dùng không tồn tại", null));
    }

    private Nhom findNhomByIdHelper(Integer nhomId) {
        return nhomRepository.findById(nhomId).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Nhóm không tồn tại", null));
    }

    private LopHoc findLopHocByIdHelper(Integer lopHocId) {
        return lopHocRepository.findById(lopHocId).orElseThrow(() -> new AppException(HttpStatus.BAD_REQUEST, "Lớp học không tồn tại", null));
    }

    private void checkThanhVienNhom(Integer nhomId, Integer userId) {
        nhomThanhVienRepository.findById_NhomIdAndId_NguoiDungId(nhomId, userId).orElseThrow(() -> new AppException(HttpStatus.FORBIDDEN, "Bạn không phải là thành viên của nhóm này", null));
    }

    private void checkThanhVienLop(Integer lopHocId, NguoiDung nguoiDung) {
        if (nguoiDung.getLopHoc() == null || !nguoiDung.getLopHoc().getId().equals(lopHocId)) {
            // Có thể cho phép các loại tài khoản khác (GV, Admin) xem? Tùy logic
            if (nguoiDung.getLoaiTaiKhoan() != LoaiNguoiDung.SinhVien && nguoiDung.getLoaiTaiKhoan() != LoaiNguoiDung.CanBoLop) {
                // Allow other roles like Admin, CanBoPhongBan maybe?
            } else {
                throw new AppException(HttpStatus.FORBIDDEN, "Bạn không thuộc lớp học này", null);
            }
        }
    }

    // Placeholder - Cần logic kiểm tra vai trò thực tế
    private boolean isAdminNhom(Integer nhomId, Integer userId) {
        if (userId == null) return false;
        return nhomThanhVienRepository.findById_NhomIdAndId_NguoiDungId(nhomId, userId).map(tv -> "QuanTriVien".equalsIgnoreCase(tv.getVaiTroTrongNhom())).orElse(false);
    }

    // Placeholder - Cần logic kiểm tra vai trò thực tế
    private boolean isCanBoLop(Integer userId, Integer lopHocId) {
        if (userId == null || lopHocId == null) return false;
        return nguoiDungRepository.findById(userId).map(nd -> nd.getLoaiTaiKhoan() == LoaiNguoiDung.CanBoLop && nd.getLopHoc() != null && nd.getLopHoc().getId().equals(lopHocId)).orElse(false);
    }

}


/* ===== src\main\resources\application.yml ===== */
server:
  port: 8080

spring:
  main:
    lazy-initialization: true
  datasource:
    url: jdbc:mysql://localhost:3307/db_nckh_he_thong_lien_lac_sinh_vien
    username: root
    password: 123456789
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true

/* ===== src\test\java\com\hau\websocket\WebSocketApplicationTests.java ===== */
package com.hau.websocket;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class WebSocketApplicationTests {

    @Test
    void contextLoads() {
    }

}



/* ===== IGNORED FILES & DIRECTORIES ===== */
/* The following items were excluded based on ignore rules */

/* .gitignore patterns: */
/*   HELP.md */
/*   target/ */
/*   !.mvn/wrapper/maven-wrapper.jar */
/*   !**/src/main/**/target/ */
/*   !**/src/test/**/target/ */
/*   .apt_generated */
/*   .classpath */
/*   .factorypath */
/*   .project */
/*   .settings */
/*   .springBeans */
/*   .sts4-cache */
/*   .idea */
/*   *.iws */
/*   *.iml */
/*   *.ipr */
/*   /nbproject/private/ */
/*   /nbbuild/ */
/*   /dist/ */
/*   /nbdist/ */
/*   /.nb-gradle/ */
/*   build/ */
/*   !**/src/main/**/build/ */
/*   !**/src/test/**/build/ */
/*   .vscode/ */

/* Ignored items list: */
/* Ignored directories: */
/*   .codebase/ */
/*   .idea/ */
/*   target\classes/ */
/*   target\generated-sources/ */
/*   target\generated-test-sources/ */
/*   target\test-classes/ */

/* Ignored files: */
/*   .vscode\settings.json */
/*   HELP.md */
